<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="技术文档">
    
    <link rel="preload" href="/book-docs/vue-depth-analysis/assets/css/0.styles.aa1e90bd.css" as="style"><link rel="preload" href="/book-docs/vue-depth-analysis/assets/js/app.186b0384.js" as="script"><link rel="preload" href="/book-docs/vue-depth-analysis/assets/js/2.d669090a.js" as="script"><link rel="preload" href="/book-docs/vue-depth-analysis/assets/js/10.7852d010.js" as="script"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/11.b88ae913.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/12.8d172228.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/13.ce31926b.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/14.967cef5e.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/15.635a9e78.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/16.746833fb.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/17.b5030f17.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/18.b41eb005.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/19.bb0ceb6c.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/20.e08a7e67.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/21.ceb288f7.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/22.f5a9ebe3.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/23.d95b6104.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/3.c431a2cd.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/4.b2e60800.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/5.17163f3d.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/6.bfaa3de2.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/7.1e431d66.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/8.b732416c.js"><link rel="prefetch" href="/book-docs/vue-depth-analysis/assets/js/9.712a636c.js">
    <link rel="stylesheet" href="/book-docs/vue-depth-analysis/assets/css/0.styles.aa1e90bd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book-docs/vue-depth-analysis/" class="home-link router-link-active"><!----> <span class="site-name">技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/book-docs/vue-depth-analysis/vue插槽，你想了解的都在这里.html" class="sidebar-link">vue插槽，你想了解的都在这里.md</a></li><li><a href="/book-docs/vue-depth-analysis/丰富的选项合并策略.html" class="sidebar-link">丰富的选项合并策略.md</a></li><li><a href="/book-docs/vue-depth-analysis/你真的了解v-model的语法糖了吗.html" class="sidebar-link">你真的了解v-model的语法糖了吗.md</a></li><li><a href="/book-docs/vue-depth-analysis/动态组件的深入分析.html" class="sidebar-link">动态组件的深入分析.md</a></li><li><a href="/book-docs/vue-depth-analysis/基础的数据代理检测.html" class="active sidebar-link">基础的数据代理检测.md</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book-docs/vue-depth-analysis/基础的数据代理检测.html#_2-1-数据代理的含义" class="sidebar-link">2.1 数据代理的含义</a></li><li class="sidebar-sub-header"><a href="/book-docs/vue-depth-analysis/基础的数据代理检测.html#_2-2-initproxy" class="sidebar-link">2.2 initProxy</a></li><li class="sidebar-sub-header"><a href="/book-docs/vue-depth-analysis/基础的数据代理检测.html#_2-3-小结" class="sidebar-link">2.3 小结</a></li></ul></li><li><a href="/book-docs/vue-depth-analysis/完整渲染流程.html" class="sidebar-link">完整渲染流程.md</a></li><li><a href="/book-docs/vue-depth-analysis/实例挂载流程和模板编译.html" class="sidebar-link">实例挂载流程和模板编译.md</a></li><li><a href="/book-docs/vue-depth-analysis/彻底搞懂Vue中keep-alive的魔法-上.html" class="sidebar-link">彻底搞懂Vue中keep-alive的魔法-上.md</a></li><li><a href="/book-docs/vue-depth-analysis/彻底搞懂Vue中keep-alive的魔法-下.html" class="sidebar-link">彻底搞懂Vue中keep-alive的魔法-下.md</a></li><li><a href="/book-docs/vue-depth-analysis/揭秘Vue的事件机制.html" class="sidebar-link">揭秘Vue的事件机制.md</a></li><li><a href="/book-docs/vue-depth-analysis/来，跟我一起实现diff算法.html" class="sidebar-link">来，跟我一起实现diff算法.md</a></li><li><a href="/book-docs/vue-depth-analysis/深入响应式系统构建-上.html" class="sidebar-link">深入响应式系统构建-上.md</a></li><li><a href="/book-docs/vue-depth-analysis/深入响应式系统构建-下.html" class="sidebar-link">深入响应式系统构建-下.md</a></li><li><a href="/book-docs/vue-depth-analysis/深入响应式系统构建-中.html" class="sidebar-link">深入响应式系统构建-中.md</a></li><li><a href="/book-docs/vue-depth-analysis/组件基础剖析.html" class="sidebar-link">组件基础剖析.md</a></li><li><a href="/book-docs/vue-depth-analysis/组件高级用法.html" class="sidebar-link">组件高级用法.md</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>简单回顾一下这个系列的前两节，前两节花了大量的篇幅介绍了<code>Vue</code>的选项合并，选项合并是<code>Vue</code>实例初始化的开始，<code>Vue</code>为开发者提供了丰富的选项配置，而每个选项都严格规定了合并的策略。然而这只是初始化中的第一步，这一节我们将对另一个重点的概念深入的分析，他就是<strong>数据代理</strong>，我们知道<code>Vue</code>大量利用了代理的思想，而除了响应式系统外，还有哪些场景也需要进行数据代理呢？这是我们这节分析的重点。</p></blockquote> <h2 id="_2-1-数据代理的含义"><a href="#_2-1-数据代理的含义" class="header-anchor">#</a> 2.1 数据代理的含义</h2> <p>数据代理的另一个说法是数据劫持，当我们在访问或者修改对象的某个属性时，数据劫持可以拦截这个行为并进行额外的操作或者修改返回的结果。而我们知道<code>Vue</code>响应式系统的核心就是数据代理，代理使得数据在访问时进行依赖收集，在修改更新时对依赖进行更新，这是响应式系统的核心思路。而这一切离不开<code>Vue</code>对数据做了拦截代理。然而响应式并不是本节讨论的重点，这一节我们将看看数据代理在其他场景下的应用。在分析之前，我们需要掌握两种实现数据代理的方法：
<code>Object.defineProperty</code> 和 <code>Proxy</code>。</p> <h3 id="_2-1-1-object-defineproperty"><a href="#_2-1-1-object-defineproperty" class="header-anchor">#</a> 2.1.1 Object.defineProperty</h3> <blockquote><p>官方定义：<code>Object.defineProperty()</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p></blockquote> <p>基本用法：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><code>Object.defineProperty()</code>可以用来精确添加或修改对象的属性，只需要在<code>descriptor</code>对象中将属性特性描述清楚，<code>descriptor</code>的属性描述符有两种形式，一种是数据描述符，另一种是存取描述符，我们分别看看各自的特点。</p> <ol><li>数据描述符，它拥有四个属性配置</li></ol> <ul><li><code>configurable</code>：数据是否可删除，可配置</li> <li><code>enumerable</code>：属性是否可枚举</li> <li><code>value</code>：属性值,默认为<code>undefined</code></li> <li><code>writable</code>：属性是否可读写</li></ul> <ol start="2"><li>存取描述符，它同样拥有四个属性选项</li></ol> <ul><li><code>configurable</code>：数据是否可删除，可配置</li> <li><code>enumerable</code>：属性是否可枚举</li> <li><code>get</code>:一个给属性提供 <code>getter</code> 的方法，如果没有 <code>getter</code> 则为 <code>undefined</code>。</li> <li><code>set</code>:一个给属性提供 <code>setter</code> 的方法，如果没有 <code>setter</code> 则为 <code>undefined</code>。</li></ul> <p><strong>需要注意的是: 数据描述符的<code>value，writable</code> 和 存取描述符中的<code>get, set</code>属性不能同时存在，否则会抛出异常。</strong>
有了<code>Object.defineProperty</code>方法，我们可以方便的利用存取描述符中的<code>getter/setter</code>来进行数据的监听,这也是响应式构建的雏形。<code>getter</code>方法可以让我们在访问数据时做额外的操作处理，<code>setter</code>方法使得我们可以在数据更新时修改返回的结果。看看下面的例子,由于设置了数据代理，当我们访问对象<code>o</code>的<code>a</code>属性时，会触发<code>getter</code>执行钩子函数，当修改<code>a</code>属性的值时，会触发<code>setter</code>钩子函数去修改返回的结果。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> value<span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'获取值'</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> value
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'设置值'</span><span class="token punctuation">)</span>
        value <span class="token operator">=</span> qqq
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
o<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'sss'</span> 
<span class="token comment">// 设置值</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
<span class="token comment">// 获取值</span>
<span class="token comment">// 'qqq'</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>前面说到<code>Object.defineProperty</code>的<code>get</code>和<code>set</code>方法是对对象进行监测并响应变化，那么数组类型是否也可以监测呢，参照监听属性的思路，我们用数组的下标作为属性，数组的元素作为拦截对象，看看<code>Object.defineProperty</code>是否可以对数组的数据进行监控拦截。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'数组被getter拦截'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> item
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">set</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'数组被setter拦截'</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> item <span class="token operator">=</span> value
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
<span class="token comment">// 结果</span>
数组被setter拦截
数组被getter拦截
<span class="token number">4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>显然，**已知长度的数组是可以通过索引属性来设置属性的访问器属性的。**但是数组的添加确无法进行拦截，这个也很好理解，不管是通过<code>arr.push()</code>还是<code>arr[10] = 10</code>添加的数据，数组所添加的索引值并没有预先加入数据拦截中，所以自然无法进行拦截处理。这个也是使用<code>Object.defineProperty</code>进行数据代理的弊端。为了解决这个问题，<code>Vue</code>在响应式系统中对数组的方法进行了重写，间接的解决了这个问题，详细细节可以参考后续的响应式系统分析。</p> <p>另外如果需要拦截的对象属性嵌套多层，如果没有递归去调用<code>Object.defineProperty</code>进行拦截，深层次的数据也依然无法监测。</p> <h3 id="_2-1-2-proxy"><a href="#_2-1-2-proxy" class="header-anchor">#</a> 2.1.2 Proxy</h3> <p>为了解决像数组这类无法进行数据拦截，以及深层次的嵌套问题，<code>es6</code>引入了<code>Proxy</code>的概念，它是真正在语言层面对数据拦截的定义。和<code>Object.defineProperty</code>一样，<code>Proxy</code>可以修改某些操作的默认行为，但是不同的是，<strong><code>Proxy</code>针对目标对象会创建一个新的实例对象，并将目标对象代理到新的实例对象上，</strong>。 本质的区别是后者会创建一个新的对象对原对象做代理，外界对原对象的访问，都必须先通过这层代理进行拦截处理。而拦截的结果是<strong>我们只要通过操作新的实例对象就能间接的操作真正的目标对象了</strong>。针对<code>Proxy</code>，下面是基础的写法:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> nobj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'获取值'</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'设置值'</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

nobj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'代理'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token comment">// 结果</span>
设置值
<span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token string">&quot;代理&quot;</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>上面的<code>get,set</code>是<code>Proxy</code>支持的拦截方法，而<code>Proxy</code> 支持的拦截操作有13种之多，具体可以参照<a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener noreferrer">ES6-Proxy<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文档,前面提到，<code>Object.defineProperty</code>的<code>getter</code>和<code>setter</code>方法并不适合监听拦截数组的变化，那么新引入的<code>Proxy</code>又能否做到呢？我们看下面的例子。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// console.log(&quot;获取数组元素&quot; + key);</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'设置数组'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 1. 改变已存在索引的数据</span>
obj<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
<span class="token comment">// result: 设置数组</span>
<span class="token comment">// 2. push,unshift添加数据</span>
obj<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token comment">// result: 设置数组 * 2 (索引和length属性都会触发setter)</span>
<span class="token comment">// // 3. 直接通过索引添加数组</span>
obj<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span>
<span class="token comment">// result: 设置数组 * 2</span>
<span class="token comment">// // 4. 删除数组元素</span>
obj<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>显然<code>Proxy</code>完美的解决了数组的监听检测问题，针对数组添加数据，删除数据的不同方法，代理都能很好的拦截处理。另外<code>Proxy</code>也很好的解决了深层次嵌套对象的问题，具体读者可以自行举例分析。</p> <h2 id="_2-2-initproxy"><a href="#_2-2-initproxy" class="header-anchor">#</a> 2.2 initProxy</h2> <p>数据拦截的思想除了为构建响应式系统准备，它也可以为<strong>数据进行筛选过滤</strong>，我们接着往下看初始化的代码，在合并选项后，<code>vue</code>接下来会为<code>vm</code>实例设置一层代理，这层代理可以为<strong>vue在模板渲染时进行一层数据筛选</strong>，这个过程究竟怎么发生的，我们看代码的实现。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 选项合并</span>
    <span class="token operator">...</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 对vm实例进行一层代理</span>
        <span class="token function">initProxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>initProxy</code>的实现如下：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 代理函数</span>
<span class="token keyword">var</span> <span class="token function-variable function">initProxy</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">initProxy</span> <span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hasProxy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options<span class="token punctuation">;</span>
        <span class="token keyword">var</span> handlers <span class="token operator">=</span> options<span class="token punctuation">.</span>render <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>render<span class="token punctuation">.</span>_withStripped
            <span class="token operator">?</span> getHandler
            <span class="token operator">:</span> hasHandler<span class="token punctuation">;</span>
        <span class="token comment">// 代理vm实例到vm属性_renderProxy</span>
        vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> handlers<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>首先是判断浏览器是否支持原生的<code>proxy</code>。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> hasProxy <span class="token operator">=</span>
      <span class="token keyword">typeof</span> Proxy <span class="token operator">!==</span> <span class="token string">'undefined'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isNative</span><span class="token punctuation">(</span>Proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>当浏览器支持<code>Proxy</code>时，<code>vm._renderProxy</code>会代理<code>vm</code>实例，并且代理过程也会随着参数的不同呈现不同的效果；当浏览器不支持<code>Proxy</code>时，直接将<code>vm</code>赋值给<code>vm._renderProxy</code>。</p> <p>读到这里，我相信大家会有很多的疑惑。
<strong>1. 这层代理的访问时机是什么，也就是说什么场景会触发这层代理</strong> <strong>2. 参数<code>options.render._withStripped</code>代表着什么，<code>getHandler</code>和<code>hasHandler</code>又有什么不同。</strong> <strong>3. 如何理解为模板数据的访问进行数据筛选过滤。到底有什么数据需要过滤。</strong> <strong>4. 只有在支持原生<code>proxy</code>环境下才会建立这层代理，那么在旧的浏览器，非法的数据又将如何展示。</strong></p> <p>带着这些疑惑，我们接着往下分析。</p> <h3 id="_2-2-1-触发代理"><a href="#_2-2-1-触发代理" class="header-anchor">#</a> 2.2.1 触发代理</h3> <p>源码中<code>vm._renderProxy</code>的使用出现在<code>Vue</code>实例的<code>_render</code>方法中，<code>Vue.prototype._render</code>是将渲染函数转换成<code>Virtual DOM</code>的方法，这部分是关于实例的挂载和模板引擎的解析，笔者并不会在这一章节中深入分析，我们只需要先有一个认知，**<code>Vue</code>内部在<code>js</code>和真实<code>DOM</code>节点中设立了一个中间层，这个中间层就是<code>Virtual DOM</code>，遵循<code>js -&gt; virtual -&gt; 真实dom</code>的转换过程,而<code>Vue.prototype._render</code>是前半段的转换，**当我们调用<code>render</code>函数时，代理的<code>vm._renderProxy</code>对象便会访问到。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ···
    <span class="token comment">// 调用vm._renderProxy</span>
    vnode <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_renderProxy<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$createElement<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>那么代理的处理函数又是什么？我们回过头看看代理选项<code>handlers</code>的实现。
<code>handers</code>函数会根据 <code>options.render._withStripped</code>的不同执行不同的代理函数，<strong>当使用类似<code>webpack</code>这样的打包工具时，通常会使用<code>vue-loader</code>插件进行模板的编译，这个时候<code>options.render</code>是存在的，并且<code>_withStripped</code>的属性也会设置为<code>true</code></strong>(关于编译版本和运行时版本的区别可以参考后面章节)，所以此时代理的选项是<code>hasHandler</code>,在其他场景下，代理的选项是<code>getHandler</code>。<code>getHandler,hasHandler</code>的逻辑相似，我们只分析使用<code>vue-loader</code>场景下<code>hasHandler</code>的逻辑。另外的逻辑，读者可以自行分析。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> hasHandler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// key in obj或者with作用域时，会触发has的钩子</span>
    <span class="token function-variable function">has</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">has</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ···
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>hasHandler</code>函数定义了<code>has</code>的钩子，前面介绍过,<code>proxy</code>的钩子有13个之多，而<code>has</code>是其中一个，它用来拦截<code>propKey in proxy</code>的操作，返回一个布尔值。而除了拦截 <code>in</code> 操作符外，<code>has</code>钩子同样可以用来拦截<code>with</code>语句下的作用对象。例如:</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> nObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token comment">// { a: 1 }</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// a</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">with</span><span class="token punctuation">(</span>nObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    a <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>那么这两个触发条件是否跟<code>_render</code>过程有直接的关系呢？答案是肯定的。<code>vnode = render.call(vm._renderProxy, vm.$createElement);</code>的主体是<code>render</code>函数，而这个<code>render</code>函数就是包装成<code>with</code>的执行语句,**在执行<code>with</code>语句的过程中，该作用域下变量的访问都会触发<code>has</code>钩子，这也是模板渲染时之所有会触发代理拦截的原因。**我们通过代码来观察<code>render</code>函数的原形。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span>     
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>render<span class="token punctuation">)</span>

<span class="token comment">//输出, 模板渲染使用with语句</span>
ƒ <span class="token function">anonymous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span><span class="token punctuation">{</span>attrs<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">&quot;id&quot;</span><span class="token operator">:</span><span class="token string">&quot;app&quot;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token function">_v</span><span class="token punctuation">(</span><span class="token function">_s</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">_s</span><span class="token punctuation">(</span>_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_2-2-2-数据过滤"><a href="#_2-2-2-数据过滤" class="header-anchor">#</a> 2.2.2 数据过滤</h3> <p>我们已经大致知道了<code>Proxy</code>代理的访问时机，那么设置这层代理的作用又在哪里呢？首先思考一个问题，我们通过<code>data</code>选项去设置实例数据，那么这些数据可以随着个人的习惯任意命名吗？显然不是的，如果你使用<code>js</code>的关键字(像<code>Object,Array,NaN</code>)去命名,这是不被允许的。另一方面，<code>Vue</code>源码内部使用了以<code>$,_</code>作为开头的内部变量，所以以<code>$,_</code>开头的变量名也是不被允许的，这就构成了数据过滤监测的前提。接下来我们具体看<code>hasHandler</code>的细节实现。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> hasHandler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">has</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">has</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> has <span class="token operator">=</span> key <span class="token keyword">in</span> target<span class="token punctuation">;</span>
        <span class="token comment">// isAllowed用来判断模板上出现的变量是否合法。</span>
        <span class="token keyword">var</span> isAllowed <span class="token operator">=</span> <span class="token function">allowedGlobals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">||</span>
            <span class="token punctuation">(</span><span class="token keyword">typeof</span> key <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'_'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> target<span class="token punctuation">.</span>$data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// _和$开头的变量不允许出现在定义的数据中，因为他是vue内部保留属性的开头。</span>
        <span class="token comment">// 1. warnReservedPrefix: 警告不能以$ _开头的变量</span>
        <span class="token comment">// 2. warnNonPresent: 警告模板出现的变量在vue实例中未定义</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>has <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target<span class="token punctuation">.</span>$data<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">warnReservedPrefix</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token function">warnNonPresent</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> has <span class="token operator">||</span> <span class="token operator">!</span>isAllowed
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 模板中允许出现的非vue实例定义的变量</span>
<span class="token keyword">var</span> allowedGlobals <span class="token operator">=</span> <span class="token function">makeMap</span><span class="token punctuation">(</span>
    <span class="token string">'Infinity,undefined,NaN,isFinite,isNaN,'</span> <span class="token operator">+</span>
    <span class="token string">'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,'</span> <span class="token operator">+</span>
    <span class="token string">'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,'</span> <span class="token operator">+</span>
    <span class="token string">'require'</span> <span class="token comment">// for Webpack/Browserify</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>首先<code>allowedGlobals</code>定义了<code>javascript</code>保留的关键字，这些关键字是不允许作为用户变量存在的。<code>(typeof key === 'string' &amp;&amp; key.charAt(0) === '_' &amp;&amp; !(key in target.$data)</code>的逻辑对以<code>$,_</code>开头，或者是否是<code>data</code>中未定义的变量做判断过滤。这里对未定义变量的场景多解释几句，前面说到，代理的对象<code>vm.renderProxy</code>是在执行<code>_render</code>函数中访问的，而在使用了<code>template</code>模板的情况下，<code>render</code>函数是对模板的解析结果，换言之，之所以会触发数据代理拦截是因为模板中使用了变量，例如<code>&lt;div&gt;}&lt;/div&gt;</code>。而如果我们在模板中使用了未定义的变量，这个过程就被<code>proxy</code>拦截，并定义为不合法的变量使用。</p> <p>我们可以看看两个报错信息的源代码(是不是很熟悉):</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 模板使用未定义的变量</span>
<span class="token keyword">var</span> <span class="token function-variable function">warnNonPresent</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
    <span class="token string">&quot;Property or method \&quot;&quot;</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">&quot;\&quot; is not defined on the instance but &quot;</span> <span class="token operator">+</span>
    <span class="token string">'referenced during render. Make sure that this property is reactive, '</span> <span class="token operator">+</span>
    <span class="token string">'either in the data option, or for class-based components, by '</span> <span class="token operator">+</span>
    <span class="token string">'initializing the property. '</span> <span class="token operator">+</span>
    <span class="token string">'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.'</span><span class="token punctuation">,</span>
    target
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用$,_开头的变量</span>
<span class="token keyword">var</span> <span class="token function-variable function">warnReservedPrefix</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span>
    <span class="token string">&quot;Property \&quot;&quot;</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">&quot;\&quot; must be accessed with \&quot;$data.&quot;</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">&quot;\&quot; because &quot;</span> <span class="token operator">+</span>
    <span class="token string">'properties starting with &quot;$&quot; or &quot;_&quot; are not proxied in the Vue instance to '</span> <span class="token operator">+</span>
    <span class="token string">'prevent conflicts with Vue internals'</span> <span class="token operator">+</span>
    <span class="token string">'See: https://vuejs.org/v2/api/#data'</span><span class="token punctuation">,</span>
    target
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>分析到这里，前面的疑惑只剩下最后一个问题。只有在浏览器支持<code>proxy</code>的情况下，才会执行<code>initProxy</code>设置代理，那么在不支持的情况下，数据过滤就失效了，此时非法的数据定义还能正常运行吗？我们先对比下面两个结论。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// 模板中使用_开头的变量，且在data选项中有定义</span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>_test<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    el<span class="token operator">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
        _test<span class="token operator">:</span> <span class="token string">'proxy'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ol><li>支持<code>proxy</code>浏览器的结果</li></ol> <p><img src="/book-docs/vue-depth-analysisassets/img/2.1.e8bb3596.png" alt=""></p> <ol start="2"><li>不支持<code>proxy</code>浏览器的结果</li></ol> <p><img src="/book-docs/vue-depth-analysisassets/img/2.2.2ead8364.png" alt=""></p> <p>显然，在没有经过代理的情况下，使用<code>_</code>开头的变量依旧会
报错，但是它变成了<code>js</code>语言层面的错误，表示该变量没有被声明。但是这个报错无法在<code>Vue</code>这一层知道错误的详细信息，而这就是能使用<code>Proxy</code>的好处。接着我们会思考，既然已经在<code>data</code>选项中定义了<code>_test</code>变量，为什么访问时还是找不到变量的定义呢？
原来在初始化数据阶段，<code>Vue</code>已经为数据进行了一层筛选的代理。具体看<code>initData</code>对数据的代理，其他实现细节不在本节讨论范围内。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">initData</span><span class="token punctuation">(</span><span class="token parameter">vm</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    vm<span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token keyword">typeof</span> data <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function">getData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> vm<span class="token punctuation">)</span> <span class="token operator">:</span> data <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isReserved</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 数据代理，用户可直接通过vm实例返回data数据</span>
        <span class="token function">proxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&quot;_data&quot;</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isReserved</span> <span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 首字符是$, _的字符串</span>
    <span class="token keyword">return</span> c <span class="token operator">===</span> <span class="token number">0x24</span> <span class="token operator">||</span> c <span class="token operator">===</span> <span class="token number">0x5F</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><code>vm._data</code>可以拿到最终<code>data</code>选项合并的结果，<code>isReserved</code>会过滤以<code>$,_</code>开头的变量，<code>proxy</code>会为实例数据的访问做代理，当我们访问<code>this.message</code>时，实际上访问的是<code>this._data.message</code>,而有了<code>isReserved</code>的筛选，即使<code>this._data._test</code>存在，我们依旧无法在访问<code>this._test</code>时拿到<code>_test</code>变量。这就解释了为什么会有变量没有被声明的语法错误，而<code>proxy</code>的实现，又是基于上述提到的<code>Object.defineProperty</code>来实现的。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">proxy</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> sourceKey<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token function-variable function">get</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">proxyGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当访问this[key]时，会代理访问this._data[key]的值</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    sharedPropertyDefinition<span class="token punctuation">.</span><span class="token function-variable function">set</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">proxySetter</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">[</span>sourceKey<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> sharedPropertyDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_2-3-小结"><a href="#_2-3-小结" class="header-anchor">#</a> 2.3 小结</h2> <p>这一节内容，详细的介绍了数据代理在<code>Vue</code>的实现思路和另一个应用场景，数据代理是一种设计模式，也是一种编程思想，<code>Object.defineProperty</code>和<code>Proxy</code>都可以实现数据代理，但是他们各有优劣，前者兼容性较好，但是却无法对数组或者嵌套的对象进行代理监测，而<code>Proxy</code>基本可以解决所有的问题，但是对兼容性要求很高。<code>Vue</code>中的响应式系统是以<code>Object.defineProperty</code>实现的，但是这并不代表没有<code>Proxy</code>的应用。<code>initProxy</code>就是其中的例子，这层代理会在模板渲染时对一些非法或者没有定义的变量进行筛选判断，和没有数据代理相比，非法的数据定义错误会提前到应用层捕获，这也有利于开发者对错误的排查。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book-docs/vue-depth-analysis/动态组件的深入分析.html" class="prev">
        动态组件的深入分析.md
      </a></span> <span class="next"><a href="/book-docs/vue-depth-analysis/完整渲染流程.html">
        完整渲染流程.md
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/book-docs/vue-depth-analysis/assets/js/app.186b0384.js" defer></script><script src="/book-docs/vue-depth-analysis/assets/js/2.d669090a.js" defer></script><script src="/book-docs/vue-depth-analysis/assets/js/10.7852d010.js" defer></script>
  </body>
</html>
