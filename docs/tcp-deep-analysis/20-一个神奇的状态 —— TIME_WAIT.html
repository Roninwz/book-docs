<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="技术文档">
    
    <link rel="preload" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.0ea9dfb1.css" as="style"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/app.411d3f03.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/19.1c34c4fb.js" as="script"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/10.f0096057.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/11.afe0018d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/12.8691dd56.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/13.4570bab2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/14.6bb5eaad.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/15.d523fd97.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/16.be91c86f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/17.4f301f0a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/18.e0b82547.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/20.5b297df0.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/21.1e4f6afa.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/22.1fd8c44a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/23.4806d06d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/24.64abf514.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/25.1db6ae87.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/26.79028ade.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/27.49378cc8.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/28.3f365d4e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/29.9e4d2797.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/3.874bed90.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/30.4e5f15e1.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/31.b0e97354.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/32.5ebf2421.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/33.75327db6.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/34.6fcf5c05.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/35.2076a0c2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/36.db825ac9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/37.3ce92f36.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/38.4afa2433.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/39.e7e9657a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/4.0892ecd3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/40.c62d5047.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/41.69a88bf2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/42.e6229e54.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/43.e36841dc.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/44.8e5155d3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/45.4c2a7d70.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/46.9ae4ac37.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/47.a075a79f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/5.864d5a79.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/6.19b45fc3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/7.2a1330f4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/8.8683fe45.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/9.c6213155.js">
    <link rel="stylesheet" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.0ea9dfb1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book-docs/tcp-deep-analysis/" class="home-link router-link-active"><!----> <span class="site-name">技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/book-docs/tcp-deep-analysis/1-开篇词 —— 小册食用指南.html" class="sidebar-link">1-开篇词 —— 小册食用指南.md</a></li><li><a href="/book-docs/tcp-deep-analysis/2-TCP_IP 历史与分层模型.html" class="sidebar-link">2-TCP_IP 历史与分层模型.md</a></li><li><a href="/book-docs/tcp-deep-analysis/3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.html" class="sidebar-link">3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.md</a></li><li><a href="/book-docs/tcp-deep-analysis/4-来自 Google 的协议栈测试神器 —— packetdrill.html" class="sidebar-link">4-来自 Google 的协议栈测试神器 —— packetdrill.md</a></li><li><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html" class="sidebar-link">5-支撑 TCP 协议的基石 —— 剖析首部字段.md</a></li><li><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html" class="sidebar-link">6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.md</a></li><li><a href="/book-docs/tcp-deep-analysis/7-繁忙的贸易港口 —— 聊聊端口号.html" class="sidebar-link">7-繁忙的贸易港口 —— 聊聊端口号.md</a></li><li><a href="/book-docs/tcp-deep-analysis/8-临时端口号是如何分配的.html" class="sidebar-link">8-临时端口号是如何分配的.md</a></li><li><a href="/book-docs/tcp-deep-analysis/9-TCP 恋爱史第一步 —— 从三次握手说起.html" class="sidebar-link">9-TCP 恋爱史第一步 —— 从三次握手说起.md</a></li><li><a href="/book-docs/tcp-deep-analysis/10-聊聊 TCP 自连接那些事.html" class="sidebar-link">10-聊聊 TCP 自连接那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/11-相见时难别亦难 —— 谈谈四次挥手.html" class="sidebar-link">11-相见时难别亦难 —— 谈谈四次挥手.md</a></li><li><a href="/book-docs/tcp-deep-analysis/12-时光机 —— TCP 头部时间戳选项.html" class="sidebar-link">12-时光机 —— TCP 头部时间戳选项.md</a></li><li><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html" class="sidebar-link">13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.md</a></li><li><a href="/book-docs/tcp-deep-analysis/14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.html" class="sidebar-link">14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.md</a></li><li><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html" class="sidebar-link">15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/16-嫌三次握手太慢 —— 来快速打开吧.html" class="sidebar-link">16-嫌三次握手太慢 —— 来快速打开吧.md</a></li><li><a href="/book-docs/tcp-deep-analysis/17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.html" class="sidebar-link">17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.md</a></li><li><a href="/book-docs/tcp-deep-analysis/18-一台主机上两个进程可以同时监听同一个端口吗.html" class="sidebar-link">18-一台主机上两个进程可以同时监听同一个端口吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/19-优雅关闭连接 —— Socket 选项之 SO_LINGER.html" class="sidebar-link">19-优雅关闭连接 —— Socket 选项之 SO_LINGER.md</a></li><li><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html" class="active sidebar-link">20-一个神奇的状态 —— TIME_WAIT.md</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#msl-max-segment-lifetime" class="sidebar-link">MSL：Max Segment Lifetime</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#构造一个-time-wait" class="sidebar-link">构造一个 TIME_WAIT</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#time-wait-存在的原因是什么" class="sidebar-link">TIME_WAIT 存在的原因是什么</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#为什么时间是两个-msl" class="sidebar-link">为什么时间是两个 MSL</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#time-wait-的问题" class="sidebar-link">TIME_WAIT 的问题</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#应对-time-wait-的各种操作" class="sidebar-link">应对 TIME_WAIT 的各种操作</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#tcp-头部时间戳选项-tcp-timestamps-option-tsopt" class="sidebar-link">TCP 头部时间戳选项（TCP Timestamps Option，TSopt）</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#tcp-tw-reuse-选项" class="sidebar-link">tcp_tw_reuse 选项</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#tcp-tw-recyle-选项" class="sidebar-link">tcp_tw_recyle 选项</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#小结" class="sidebar-link">小结</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#习题" class="sidebar-link">习题</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html#思考题" class="sidebar-link">思考题</a></li></ul></li><li><a href="/book-docs/tcp-deep-analysis/21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.html" class="sidebar-link">21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.md</a></li><li><a href="/book-docs/tcp-deep-analysis/22-重传机制 —— 超时重传、快速重传与 SACK.html" class="sidebar-link">22-重传机制 —— 超时重传、快速重传与 SACK.md</a></li><li><a href="/book-docs/tcp-deep-analysis/23-重传间隔有讲究 —— 多久重传才合适.html" class="sidebar-link">23-重传间隔有讲究 —— 多久重传才合适.md</a></li><li><a href="/book-docs/tcp-deep-analysis/24-TCP流量控制 —— 滑动窗口.html" class="sidebar-link">24-TCP流量控制 —— 滑动窗口.md</a></li><li><a href="/book-docs/tcp-deep-analysis/25-有风度的 TCP —— 拥塞控制.html" class="sidebar-link">25-有风度的 TCP —— 拥塞控制.md</a></li><li><a href="/book-docs/tcp-deep-analysis/26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.html" class="sidebar-link">26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html" class="sidebar-link">27-TCP 回包的磨叽姐 —— 延迟确认那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/28-兄弟你还活着吗 —— keepalive 原理.html" class="sidebar-link">28-兄弟你还活着吗 —— keepalive 原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html" class="sidebar-link">29-TCP RST 攻击与如何杀掉一条 TCP 连接.md</a></li><li><a href="/book-docs/tcp-deep-analysis/30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.html" class="sidebar-link">30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.md</a></li><li><a href="/book-docs/tcp-deep-analysis/31-定时器一览 —— 细数 TCP 的定时器们.html" class="sidebar-link">31-定时器一览 —— 细数 TCP 的定时器们.md</a></li><li><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html" class="sidebar-link">32-网络工具篇（一） —— telnet、nc、netstat.md</a></li><li><a href="/book-docs/tcp-deep-analysis/33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.html" class="sidebar-link">33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.md</a></li><li><a href="/book-docs/tcp-deep-analysis/34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.html" class="sidebar-link">34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.md</a></li><li><a href="/book-docs/tcp-deep-analysis/35-案例分析 —— JDBC 批量插入真的就批量了吗.html" class="sidebar-link">35-案例分析 —— JDBC 批量插入真的就批量了吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/36-案例分析 —— TCP RST 包导致的网络血案.html" class="sidebar-link">36-案例分析 —— TCP RST 包导致的网络血案.md</a></li><li><a href="/book-docs/tcp-deep-analysis/37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.html" class="sidebar-link">37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.md</a></li><li><a href="/book-docs/tcp-deep-analysis/38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.html" class="sidebar-link">38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/39-作业题和思考题解析.html" class="sidebar-link">39-作业题和思考题解析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/40-网络学习一路困难，与君共勉.html" class="sidebar-link">40-网络学习一路困难，与君共勉.md</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>TIME_WAIT 是 TCP 所有状态中最不好理解的一种状态。首先，我们需要明确，<strong>只有主动断开的那一方才会进入 TIME_WAIT 状态</strong>，且会在那个状态持续 2 个 MSL（Max Segment Lifetime）。</p> <p>为了讲清楚 TIME_WAIT，需要先介绍一下 MSL 的概念。</p> <h2 id="msl-max-segment-lifetime"><a href="#msl-max-segment-lifetime" class="header-anchor">#</a> MSL：Max Segment Lifetime</h2> <p>MSL（报文最大生存时间）是 TCP 报文在网络中的最大生存时间。这个值与 IP 报文头的 TTL 字段有密切的关系。</p> <p>IP 报文头中有一个 8 位的存活时间字段（Time to live, TTL）如下图。 这个存活时间存储的不是具体的时间，而是一个 IP 报文最大可经过的路由数，每经过一个路由器，TTL 减 1，当 TTL 减到 0 时这个 IP 报文会被丢弃。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4b9038f7aa" alt=""></p> <p>TTL 经过路由器不断减小的过程如下图所示，假设初始的 TTL 为 12，经过下一个路由器 R1 以后 TTL 变为 11，后面每经过一个路由器以后 TTL 减 1</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4b904314f8" alt=""></p> <p>从上面可以看到 TTL 说的是「跳数」限制而不是「时间」限制，尽管如此我们依然假设<strong>最大跳数的报文在网络中存活的时间不可能超过 MSL 秒</strong>。Linux 的套接字实现假设 MSL 为 30 秒，因此在 Linux 机器上 TIME_WAIT 状态将持续 60秒。</p> <h2 id="构造一个-time-wait"><a href="#构造一个-time-wait" class="header-anchor">#</a> 构造一个 TIME_WAIT</h2> <p>要构造一个 TIME_WAIT 非常简单，只需要建立一个 TCP 连接，然后断开某一方连接，主动断开的那一方就会进入 TIME_WAIT 状态，我们用 Linux 上开箱即用的 nc 命令来构造一个。过程如下图：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4b90306b56" alt=""></p> <ul><li><p>在机器 c2 上用<code>nc -l 8888</code>启动一个 TCP 服务器</p></li> <li><p>在机器 c1 上用 <code>nc c2 8888</code> 创建一条 TCP 连接</p></li> <li><p>在机器 c1 上用 <code>Ctrl+C</code> 停止 nc 命令，随后在用<code>netstat -atnp | grep 8888</code>查看连接状态。</p> <p>netstat -atnp | grep 8888
tcp        0      0 10.211.55.5:60494       10.211.55.10:8888       TIME_WAIT   -</p></li></ul> <h2 id="time-wait-存在的原因是什么"><a href="#time-wait-存在的原因是什么" class="header-anchor">#</a> TIME_WAIT 存在的原因是什么</h2> <p>第一个原因是：数据报文可能在发送途中延迟但最终会到达，因此要等老的“迷路”的重复报文段在网络中过期失效，这样可以避免用<strong>相同</strong>源端口和目标端口创建新连接时收到旧连接姗姗来迟的数据包，造成数据错乱。</p> <p>比如下面的例子</p> <p><img src="https://user-gold-cdn.xitu.io/2019/10/15/16dce163cb0bd1d8" alt=""></p> <p>假设客户端 10.211.55.2 的 61594 端口与服务端 10.211.55.10 的 8080 端口一开始建立了一个 TCP 连接。</p> <p>假如客户端发送完 FIN 包以后不等待直接进入 CLOSED 状态，老连接 SEQ=3 的包因为网络的延迟。过了一段时间<strong>相同</strong>的 IP 和端口号又新建了另一条连接，这样 TCP 连接的四元组就完全一样了。恰好 SEQ 因为回绕等原因也正好相同，那么 SEQ=3 的包就无法知道到底是旧连接的包还是新连接的包了，造成新连接数据的混乱。</p> <p>TIME_WAIT 等待时间是 2 个 MSL，已经足够让一个方向上的包最多存活 MSL 秒就被丢弃，保证了在创建新的 TCP 连接以后，老连接姗姗来迟的包已经在网络中被丢弃消逝，不会干扰新的连接。</p> <p>第二个原因是确保可靠实现 TCP 全双工终止连接。关闭连接的四次挥手中，最终的 ACK 由主动关闭方发出，如果这个 ACK 丢失，对端（被动关闭方）将重发 FIN，如果主动关闭方不维持 TIME_WAIT 直接进入 CLOSED 状态，则无法重传 ACK，被动关闭方因此不能及时可靠释放。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4bb50e0f93" alt=""></p> <p>如果四次挥手的第 4 步中客户端发送了给服务端的确认 ACK 报文以后不进入 TIME_WAIT 状态，直接进入 <code>CLOSED</code>状态，然后重用端口建立新连接会发生什么呢？如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4bdb2a32f6" alt=""></p> <p>主动关闭方如果马上进入 <code>CLOSED</code> 状态，被动关闭方这个时候还处于<code>LAST-ACK</code>状态，主动关闭方认为连接已经释放，端口可以重用了，如果使用相同的端口三次握手发送 SYN 包，会被处于 <code>LAST-ACK</code>状态状态的被动关闭方返回一个 <code>RST</code>，三次握手失败。</p> <h2 id="为什么时间是两个-msl"><a href="#为什么时间是两个-msl" class="header-anchor">#</a> 为什么时间是两个 MSL</h2> <ul><li>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端</li> <li>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达</li></ul> <p>2MS = 去向 ACK 消息最大存活时间（MSL) + 来向 FIN 消息的最大存活时间（MSL）</p> <h2 id="time-wait-的问题"><a href="#time-wait-的问题" class="header-anchor">#</a> TIME_WAIT 的问题</h2> <p>在一个非常繁忙的服务器上，如果有大量 TIME_WAIT 状态的连接会怎么样呢？</p> <ul><li>连接表无法复用</li> <li>socket 结构体内存占用</li></ul> <p><strong>连接表无法复用</strong> 因为处于 TIME_WAIT 的连接会存活 2MSL（60s），意味着相同的TCP 连接四元组（源端口、源 ip、目标端口、目标 ip）在一分钟之内都没有办法复用，通俗一点来讲就是“占着茅坑不拉屎”。</p> <p>假设主动断开的一方是客户端，对于 web 服务器而言，目标地址、目标端口都是固定值（比如本机 ip + 80 端口），客户端的 IP 也是固定的，那么能变化的就只有端口了，在一台 Linux 机器上，端口最多是 65535 个（ 2 个字节）。如果客户端与服务器通信全部使用短连接，不停的创建连接，接着关闭连接，客户端机器会造成大量的 TCP 连接进入 TIME_WAIT 状态。</p> <p>可以来写一个简单的 shell 脚本来测试一下，使用 nc 命令连接 redis 发送 ping 命令以后断开连接。</p> <div class="language- extra-class"><pre><code>for i in {1..10000}; do
    echo ping | nc localhost 6379
done
</code></pre></div><p>查看一下处于 TIME_WAIT 状态的连接的个数，短短的几秒钟内，TIME_WAIT 状态的连接已经有了 8000 多个。</p> <div class="language- extra-class"><pre><code>netstat -tnpa | grep -i 6379 | grep  TIME_WAIT| wc -l
8192
</code></pre></div><p>如果在 60s 内有超过 65535 次 redis 短连接操作，就会出现端口不够用的情况，这也是使用连接池的一个重要原因。</p> <h2 id="应对-time-wait-的各种操作"><a href="#应对-time-wait-的各种操作" class="header-anchor">#</a> 应对 TIME_WAIT 的各种操作</h2> <p>针对 TIME_WAIT 持续时间过长的问题，Linux 新增了几个相关的选项，net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_tw_recycle。下面我们来说明一下这两个参数的用意。 这两个参数都依赖于 TCP 头部的扩展选项：timestamp</p> <h2 id="tcp-头部时间戳选项-tcp-timestamps-option-tsopt"><a href="#tcp-头部时间戳选项-tcp-timestamps-option-tsopt" class="header-anchor">#</a> TCP 头部时间戳选项（TCP Timestamps Option，TSopt）</h2> <p>除了我们之前介绍的 MSS、Window Scale 还有以一个非常重要的选项：时间戳（TCP Timestamps Option，TSopt）</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4c5c635f86" alt=""></p> <p>它由四部分构成：类别（kind）、长度（Length）、发送方时间戳（TS value）、回显时间戳（TS Echo Reply）。时间戳选项类别（kind）的值等于 8，用来与其它类型的选项区分。长度（length）等于 10。两个时间戳相关的选项都是 4 字节。</p> <p>如下图所示：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4be8611658" alt=""></p> <p>是否使用时间戳选项是在三次握手里面的 SYN 报文里面确定的。下面的包是<code>curl github.com</code>抓包得到的结果。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4be8843d80" alt=""></p> <ul><li>发送方发送数据时，将一个发送时间戳 1734581141 放在发送方时间戳<code>TSval</code>中</li> <li>接收方收到数据包以后，将收到的时间戳 1734581141 原封不动的返回给发送方，放在<code>TSecr</code>字段中，同时把自己的时间戳 3303928779 放在<code>TSval</code>中</li> <li>后面的包以此类推</li></ul> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4c5c7ae349" alt=""></p> <p>有几个需要说明的点</p> <ul><li><p>时间戳是一个单调递增的值，与我们所知的 epoch 时间戳不是一回事。这个选项不要求两台主机进行时钟同步</p></li> <li><p>timestamps 是一个双向的选项，如果只要有一方不开启，双方都将停用 timestamps。比如下面是<code>curl www.baidu.com</code>得到的包</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4c6e0a8f69" alt=""></p> <p>可以看到客户端发起 SYN 包时带上了自己的TSval，服务器回复的SYN+ACK 包没有TSval和TSecr，从此之后的包都没有带上时间戳选项了。</p></li></ul> <p>有了这个选项，我们来看一下 tcp_tw_reuse 选项</p> <h2 id="tcp-tw-reuse-选项"><a href="#tcp-tw-reuse-选项" class="header-anchor">#</a> tcp_tw_reuse 选项</h2> <p>缓解紧张的端口资源，一个可行的方法是重用“浪费”的处于 TIME_WAIT 状态的连接，当开启 net.ipv4.tcp_tw_reuse 选项时，处于 TIME_WAIT 状态的连接可以被重用。下面把主动关闭方记为 A， 被动关闭方记为 B，它的原理是：</p> <ul><li>如果主动关闭方 A 收到的包时间戳比当前存储的时间戳小，说明是一个迷路的旧连接的包，直接丢弃掉</li> <li>如果因为 ACK 包丢失导致被动关闭方还处于<code>LAST-ACK</code>状态，并且会持续重传 FIN+ACK。这时 A 发送SYN 包想三次握手建立连接，此时 A 处于<code>SYN-SENT</code>阶段。当收到 B 的 FIN 包时会回以一个 RST 包给 B，B 这端的连接会进入 CLOSED 状态，A 因为没有收到 SYN 包的 ACK，会重传 SYN，后面就一切顺利了。</li></ul> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4c6fa323bd" alt=""></p> <h2 id="tcp-tw-recyle-选项"><a href="#tcp-tw-recyle-选项" class="header-anchor">#</a> tcp_tw_recyle 选项</h2> <p>tcp_tw_recyle 是一个比 tcp_tw_reuse 更激进的方案， 系统会缓存每台主机（即 IP）连接过来的最新的时间戳。对于新来的连接，如果发现 SYN 包中带的时间戳与之前记录的来自同一主机的同一连接的分组所携带的时间戳相比更旧，则直接丢弃。如果更新则接受复用 TIME-WAIT 连接。</p> <p>这种机制在客户端与服务端一对一的情况下没有问题，如果经过了 NAT 或者负载均衡，问题就很严重了。</p> <p>什么是 NAT呢？</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/14/16b54c4c703303df" alt=""></p> <p>NAT（Network Address Translator）的出现是为了缓解 IP 地址耗尽的临时方案，IPv4 的地址是 32 位，全部利用最 多只能提 42.9 亿个地址，去掉保留地址、组播地址等剩下的只有 30 多亿，互联网主机数量呈指数级的增长，如果给每个设备都分配一个唯一的 IP 地址，那根本不够。于是 1994 年推出的 NAT 规范，NAT 设备负责维护局域网私有 IP 地址和端口到外网 IP 和端口的映射规则。</p> <p>它有两个明显的优点</p> <ul><li>出口 IP 共享：通过一个公网地址可以让许多机器连上网络，解决 IP 地址不够用的问题</li> <li>安全隐私防护：实际的机器可以隐藏自己真实的 IP 地址 当然也有明显的弊端：NAT 会对包进行修改，有些协议无法通过 NAT。</li></ul> <p>当 tcp_tw_recycle 遇上 NAT 时，因为客户端出口 IP 都一样，会导致服务端看起来都在跟同一个 host 打交道。不同客户端携带的 timestamp 只跟自己相关，如果一个时间戳较大的客户端 A 通过 NAT 与服务器建连，时间戳较小的客户端 B 通过 NAT 发送的包服务器认为是过期重复的数据，直接丢弃，导致 B 无法正常建连和发数据。</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>TIME_WAIT 状态是最容易造成混淆的一个概念，这个状态存在的意义是</p> <ul><li>可靠的实现 TCP 全双工的连接终止（处理最后 ACK 丢失的情况）</li> <li>避免当前关闭连接与后续连接混淆（让旧连接的包在网络中消逝）</li></ul> <h2 id="习题"><a href="#习题" class="header-anchor">#</a> 习题</h2> <p>1、TCP 状态变迁中，存在 TIME_WAIT 状态，请问以下正确的描述是？</p> <ul><li>A、TIME_WAIT 状态可以帮助 TCP 的全双工连接可靠释放</li> <li>B、TIME_WAIT 状态是 TCP 是三次握手过程中的状态</li> <li>C、TIME_WAIT 状态是为了保证重新生成的 socket 不受之前延迟报文的影响</li> <li>D、TIME_WAIT 状态是为了让旧数据包消失在网络中</li></ul> <h2 id="思考题"><a href="#思考题" class="header-anchor">#</a> 思考题</h2> <p>假设 MSL 是 60s，请问系统能够初始化一个新连接然后主动关闭的最大速率是多少？（忽略1~1024区间的端口）</p> <p>欢迎你在留言区留言，和我一起讨论。</p> <p><a href="https://juejin.im/book/6844733788681928712/section/6844733788837117959" target="_blank" rel="noopener noreferrer">Source<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book-docs/tcp-deep-analysis/19-优雅关闭连接 —— Socket 选项之 SO_LINGER.html" class="prev">
        19-优雅关闭连接 —— Socket 选项之 SO_LINGER.md
      </a></span> <span class="next"><a href="/book-docs/tcp-deep-analysis/21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.html">
        21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.md
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/book-docs/tcp-deep-analysis/assets/js/app.411d3f03.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/19.1c34c4fb.js" defer></script>
  </body>
</html>
