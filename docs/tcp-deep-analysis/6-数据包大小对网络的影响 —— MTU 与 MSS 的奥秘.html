<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="技术文档">
    
    <link rel="preload" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.1ae38039.css" as="style"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/app.c5d1f0fa.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/43.bba7aad7.js" as="script"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/10.456c114f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/11.4f919a5c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/12.8691dd56.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/13.6eb06c9f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/14.8ea58ce4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/15.99b76ce3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/16.892ccdbb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/17.46486d87.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/18.1ae83189.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/19.6788fb0a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/20.38eb4e81.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/21.dd2d7e3c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/22.1fd8c44a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/23.7a6fd38e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/24.4006c26f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/25.acd18f3e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/26.d393a91d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/27.5eb2dc92.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/28.2f7d9a61.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/29.1b6a2c80.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/3.086afb7c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/30.7b2345d3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/31.eec26697.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/32.05263bfb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/33.0a453fe1.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/34.6fcf5c05.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/35.2076a0c2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/36.db825ac9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/37.3ce92f36.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/38.419ced31.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/39.e7e9657a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/4.1e02d683.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/40.11cc02bb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/41.e5c285f2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/42.d1465cb7.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/44.c74f481b.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/45.4c2a7d70.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/46.917e2cae.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/47.5ae9bff9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/5.ed3e8199.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/6.19b45fc3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/7.2a1330f4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/8.8683fe45.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/9.b4387ffc.js">
    <link rel="stylesheet" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.1ae38039.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book-docs/tcp-deep-analysis/" class="home-link router-link-active"><!----> <span class="site-name">技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/book-docs/tcp-deep-analysis/1-开篇词 —— 小册食用指南.html" class="sidebar-link">1-开篇词 —— 小册食用指南.md</a></li><li><a href="/book-docs/tcp-deep-analysis/10-聊聊 TCP 自连接那些事.html" class="sidebar-link">10-聊聊 TCP 自连接那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/11-相见时难别亦难 —— 谈谈四次挥手.html" class="sidebar-link">11-相见时难别亦难 —— 谈谈四次挥手.md</a></li><li><a href="/book-docs/tcp-deep-analysis/12-时光机 —— TCP 头部时间戳选项.html" class="sidebar-link">12-时光机 —— TCP 头部时间戳选项.md</a></li><li><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html" class="sidebar-link">13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.md</a></li><li><a href="/book-docs/tcp-deep-analysis/14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.html" class="sidebar-link">14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.md</a></li><li><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html" class="sidebar-link">15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/16-嫌三次握手太慢 —— 来快速打开吧.html" class="sidebar-link">16-嫌三次握手太慢 —— 来快速打开吧.md</a></li><li><a href="/book-docs/tcp-deep-analysis/17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.html" class="sidebar-link">17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.md</a></li><li><a href="/book-docs/tcp-deep-analysis/18-一台主机上两个进程可以同时监听同一个端口吗.html" class="sidebar-link">18-一台主机上两个进程可以同时监听同一个端口吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/19-优雅关闭连接 —— Socket 选项之 SO_LINGER.html" class="sidebar-link">19-优雅关闭连接 —— Socket 选项之 SO_LINGER.md</a></li><li><a href="/book-docs/tcp-deep-analysis/2-TCP_IP 历史与分层模型.html" class="sidebar-link">2-TCP_IP 历史与分层模型.md</a></li><li><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html" class="sidebar-link">20-一个神奇的状态 —— TIME_WAIT.md</a></li><li><a href="/book-docs/tcp-deep-analysis/21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.html" class="sidebar-link">21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.md</a></li><li><a href="/book-docs/tcp-deep-analysis/22-重传机制 —— 超时重传、快速重传与 SACK.html" class="sidebar-link">22-重传机制 —— 超时重传、快速重传与 SACK.md</a></li><li><a href="/book-docs/tcp-deep-analysis/23-重传间隔有讲究 —— 多久重传才合适.html" class="sidebar-link">23-重传间隔有讲究 —— 多久重传才合适.md</a></li><li><a href="/book-docs/tcp-deep-analysis/24-TCP流量控制 —— 滑动窗口.html" class="sidebar-link">24-TCP流量控制 —— 滑动窗口.md</a></li><li><a href="/book-docs/tcp-deep-analysis/25-有风度的 TCP —— 拥塞控制.html" class="sidebar-link">25-有风度的 TCP —— 拥塞控制.md</a></li><li><a href="/book-docs/tcp-deep-analysis/26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.html" class="sidebar-link">26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html" class="sidebar-link">27-TCP 回包的磨叽姐 —— 延迟确认那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/28-兄弟你还活着吗 —— keepalive 原理.html" class="sidebar-link">28-兄弟你还活着吗 —— keepalive 原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html" class="sidebar-link">29-TCP RST 攻击与如何杀掉一条 TCP 连接.md</a></li><li><a href="/book-docs/tcp-deep-analysis/3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.html" class="sidebar-link">3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.md</a></li><li><a href="/book-docs/tcp-deep-analysis/30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.html" class="sidebar-link">30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.md</a></li><li><a href="/book-docs/tcp-deep-analysis/31-定时器一览 —— 细数 TCP 的定时器们.html" class="sidebar-link">31-定时器一览 —— 细数 TCP 的定时器们.md</a></li><li><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html" class="sidebar-link">32-网络工具篇（一） —— telnet、nc、netstat.md</a></li><li><a href="/book-docs/tcp-deep-analysis/33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.html" class="sidebar-link">33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.md</a></li><li><a href="/book-docs/tcp-deep-analysis/34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.html" class="sidebar-link">34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.md</a></li><li><a href="/book-docs/tcp-deep-analysis/35-案例分析 —— JDBC 批量插入真的就批量了吗.html" class="sidebar-link">35-案例分析 —— JDBC 批量插入真的就批量了吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/36-案例分析 —— TCP RST 包导致的网络血案.html" class="sidebar-link">36-案例分析 —— TCP RST 包导致的网络血案.md</a></li><li><a href="/book-docs/tcp-deep-analysis/37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.html" class="sidebar-link">37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.md</a></li><li><a href="/book-docs/tcp-deep-analysis/38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.html" class="sidebar-link">38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/39-作业题和思考题解析.html" class="sidebar-link">39-作业题和思考题解析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/4-来自 Google 的协议栈测试神器 —— packetdrill.html" class="sidebar-link">4-来自 Google 的协议栈测试神器 —— packetdrill.md</a></li><li><a href="/book-docs/tcp-deep-analysis/40-网络学习一路困难，与君共勉.html" class="sidebar-link">40-网络学习一路困难，与君共勉.md</a></li><li><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html" class="sidebar-link">5-支撑 TCP 协议的基石 —— 剖析首部字段.md</a></li><li><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html" class="active sidebar-link">6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.md</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html#最大传输单元-maximum-transmission-unit-mtu" class="sidebar-link">最大传输单元（Maximum Transmission Unit, MTU）</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html#ip-分段" class="sidebar-link">IP 分段</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html#网络中的木桶效应-路径-mtu" class="sidebar-link">网络中的木桶效应：路径 MTU</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html#实际模拟路径-mtu-发现" class="sidebar-link">实际模拟路径 MTU 发现</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html#tcp-最大段大小-max-segment-size-mss" class="sidebar-link">TCP 最大段大小（Max Segment Size，MSS）</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html#为什么有时候抓包看到的单个数据包大于-mtu" class="sidebar-link">为什么有时候抓包看到的单个数据包大于 MTU</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html#tcp-套接字选项-tcp-maxseg" class="sidebar-link">TCP 套接字选项 TCP_MAXSEG</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html#小结" class="sidebar-link">小结</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html#作业题" class="sidebar-link">作业题</a></li></ul></li><li><a href="/book-docs/tcp-deep-analysis/7-繁忙的贸易港口 —— 聊聊端口号.html" class="sidebar-link">7-繁忙的贸易港口 —— 聊聊端口号.md</a></li><li><a href="/book-docs/tcp-deep-analysis/8-临时端口号是如何分配的.html" class="sidebar-link">8-临时端口号是如何分配的.md</a></li><li><a href="/book-docs/tcp-deep-analysis/9-TCP 恋爱史第一步 —— 从三次握手说起.html" class="sidebar-link">9-TCP 恋爱史第一步 —— 从三次握手说起.md</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>前面的文章中介绍过一个应用层的数据包会经过传输层、网络层的层层包装，交给网络接口层传输。假设上层的应用调用 write 等函数往 socket 写入了 10KB 的数据，TCP 会如何处理呢？是直接加上 TCP 头直接交给网络层吗？这篇文章我们来讲讲这相关的知识</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e12cc8358" alt=""></p> <h2 id="最大传输单元-maximum-transmission-unit-mtu"><a href="#最大传输单元-maximum-transmission-unit-mtu" class="header-anchor">#</a> 最大传输单元（Maximum Transmission Unit, MTU）</h2> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e208c4f86" alt=""></p> <p>数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层，这个限制被称为「最大传输单元（Maximum Transmission Unit, MTU）」</p> <p>下图是以太网的帧格式，以太网的帧最小的帧是 64 字节，除去 14 字节头部和 4 字节 CRC 字段，有效荷载最小为 46 字节。最大的帧是 1518 字节，除去 14 字节头部和 4 字节 CRC，有效荷载最大为 1500，这个值就是以太网的 MTU。因此如果传输 100KB 的数据，至少需要 （100 * 1024 / 1500) = 69 个以太网帧。</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e260cd0cd" alt=""></p> <p>不同的数据链路层的 MTU 是不同的。通过<code>netstat -i</code> 可以查看网卡的 mtu，比如在 我的 centos 机器上可以看到</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e147f6672" alt=""></p> <h2 id="ip-分段"><a href="#ip-分段" class="header-anchor">#</a> IP 分段</h2> <p>IPv4 数据报的最大大小为 65535 字节，这已经远远超过了以太网的 MTU，而且有些网络还会开启巨帧（Jumbo Frame）能达到 9000 字节。 当一个 IP 数据包大于 MTU 时，IP 会把数据报文进行切割为多个小的片段(小于 MTU），使得这些小的报文可以通过链路层进行传输</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e1987f568" alt=""></p> <p>IP 头部中有一个表示分片偏移量的字段，用来表示该分段在原始数据报文中的位置，如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e185162dc" alt=""></p> <p>下面我们 wireshark 来演示 IP 分段，wireshark 开启抓包，在命令行中执行</p> <div class="language- extra-class"><pre><code>ping -s 3000 www.baidu.com

输出：
PING www.a.shifen.com (14.215.177.39): 3000 data bytes
Request timeout for icmp_seq 0
Request timeout for icmp_seq 1
Request timeout for icmp_seq 2
</code></pre></div><p>在 wireshark 的显示过滤器中输入<code>ip.addr==14.215.177.39</code></p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e4beb82ae" alt=""></p> <p>通过<code>man ping</code>命令可以看到<code>ping -s</code>命令会增加 8byte 的 ICMP 头，所以<code>ping -s 3000</code> IP 层实际会发送 3008 字节。</p> <blockquote><p>-s packetsize Specify the number of data bytes to be sent. The default is 56, which translates into 64 ICMP data bytes when combined with the 8 bytes of ICMP header data. This option cannot be used with ping sweeps.</p></blockquote> <p>先看第一个包</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e4ee94a57" alt=""></p> <p>这个包是 IP 分段包的第一个分片，<code>More fragments: Set</code>表示这个包是 IP 分段包的一部分，还有其它的分片包，<code>Fragment offset: 0</code>表示分片偏移量为 0，IP 包的 payload 的大小为 1480，加上 20 字节的头部正好是 1500</p> <p>第二个包的详情截图如下</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e4dcc0174" alt=""></p> <p>同样<code>More fragments</code>处于 set 状态，表示后面还有其它分片，<code>Fragment offset: 185</code>这里并不是表示分片偏移量为 185，wireshark 这里显示的时候除以了 8，真实的分片偏移量为 185 * 8 = 1480</p> <p>第三个包的详情截图如下</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e51db4162" alt=""></p> <p>可以看到<code>More fragments</code>处于 Not set 状态，表示这是最后一个分片了。<code>Fragment offset: 370</code>表示偏移量为 370 * 8 = 2960，包的大小为 68 - 20（IP 头部大小） = 48</p> <p>三个分片如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e54362613" alt=""></p> <p>前面我们提到 IP 协议不会对丢包进行重传，那么 IP 分段中有分片丢失、损坏的话，会发生什么呢？ 这种情况下，目标主机将没有办法将分段的数据包重组为一个完整的数据包，依赖于传输层是否进行重传。</p> <p>利用 IP 包分片的策略，有一种对应的网络攻击方式<code>IP fragment attack</code>，就是一直传<code>More fragments = 1</code>的包，导致接收方一直缓存分片，从而可能导致接收方内存耗尽。</p> <h2 id="网络中的木桶效应-路径-mtu"><a href="#网络中的木桶效应-路径-mtu" class="header-anchor">#</a> 网络中的木桶效应：路径 MTU</h2> <p>一个包从发送端传输到接收端，中间要跨越很多个网络，每条链路的 MTU 都可能不一样，这个通信过程中最小的 MTU 称为「路径 MTU（Path MTU）」。就好比开车有时候开的是双向 4 车道，有时候可能是乡间小路一样。</p> <p>比如下图中，第一段链路 MTU 大小为 1500 字节，第二段链路 MTU 为 800 字节，第三段链路 MTU 为 1200 字节，则路径 MTU 为三段 MTU 的最小值 800。</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e55a91949" alt=""></p> <p>路径 MTU 就跟木桶效应是一个道理，木桶的盛水量由最短的那条短板决定，路径 MTU 也是由通信链条中最小的 MTU 决定。</p> <h2 id="实际模拟路径-mtu-发现"><a href="#实际模拟路径-mtu-发现" class="header-anchor">#</a> 实际模拟路径 MTU 发现</h2> <p>用下面的代码可以用来测试路径 MTU 发现，为了方便，每行前面加了行号</p> <div class="language- extra-class"><pre><code>0.000 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
0.000 bind(3, ..., ...) = 0
0.000 listen(3, 1) = 0

0.100 &lt; S 0:0(0) win 32792 &lt;mss 1460,nop,wscale 7&gt;
0.100 &gt; S. 0:0(0) ack 1 &lt;mss 1460,nop,wscale 7&gt;
0.200 &lt; . 1:1(0) ack 1 win 257
0.200 accept(3, ..., ...) = 4
</code></pre></div><p>​<br>
​<br>
+0.2 write(4, ..., 1460) = 1460</p> <div class="language- extra-class"><pre><code>+0.0 &gt; P. 1:1461(1460) ack 1
</code></pre></div><p>​<br>
+0.01 &lt; icmp unreachable frag_needed mtu 1200 [1:1461(1460)]</p> <p>​<br>
+.0 &gt; . 1:1161(1160) ack 1
+0.0&gt; P. 1161:1461(300) ack 1</p> <p>​<br>
+0.1 &lt; . 1:1(0) ack 1461 win 257</p> <div class="language- extra-class"><pre><code>+0 `sleep 1000000`
</code></pre></div><p>其中在发送了 1460 大小的数据以后，这第一个数据包在 IP 层设置了不分段，之后收到一个 ICMP 告知的报文过大错误</p> <p>运行抓包如下图</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e84446756" alt=""></p> <ul><li><p>1 ~ 3：三次握手</p></li> <li><p>4：发送长度为 1460 的数据，这个数据包设置了不允许分片<code>Don't fragment: Set</code></p></li> <li><p>5：发送端收到 ICMP 包，告知包太大需要分片，下一个分片的大小按照 MTU=1200 来计算</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e81b1e6df" alt=""></p></li> <li><p>6：TCP 为了避免底层分片立刻拆包重发数据包，这次包大小为 1200 - 40 = 1160</p></li> <li><p>7：发送端发送剩下的 300 字节（1460 - 1160）</p></li> <li><p>8：确认所有的数据</p></li></ul> <p>整个过程如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e887eea11" alt=""></p> <p>因为有 MTU 的存在，TCP 每次发包的大小也限制了，这就是下面要介绍的 MSS。</p> <h2 id="tcp-最大段大小-max-segment-size-mss"><a href="#tcp-最大段大小-max-segment-size-mss" class="header-anchor">#</a> TCP 最大段大小（Max Segment Size，MSS）</h2> <p>TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称之为 MSS（Max Segment Size）。</p> <div class="language- extra-class"><pre><code>MSS = MTU - IP header头大小 - TCP 头大小
</code></pre></div><p>这样一个 MSS 的数据恰好能装进一个 MTU 而不用分片。</p> <p>在以太网中 TCP 的 MSS = 1500（MTU） - 20（IP 头大小） - 20（TCP 头大小）= 1460</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e8c79596f" alt=""></p> <p>我们来抓一个包来实际看一下，下面是下载一个 png 图片的 http 请求包 当三次握手建立一个 TCP 连接时，通信的双方会在 SYN 报文里说明自己允许的最大段大小。</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e8a06ec69" alt=""></p> <p>可以看到 TCP 的包体数据大小为 1448，因为TCP 头部里包含了 12 字节的选项（Options）字段，头部大小从之前的 20 字节变为了 32 字节，所以 TCP 包体大小变为了：1500（以太网 MTU） - 20（IP 固定表头大小） - 20（TCP 固定表头大小） - 12（TCP 表头选项） = 1448</p> <h2 id="为什么有时候抓包看到的单个数据包大于-mtu"><a href="#为什么有时候抓包看到的单个数据包大于-mtu" class="header-anchor">#</a> 为什么有时候抓包看到的单个数据包大于 MTU</h2> <p>写一个简单的代码来测试一下。</p> <p>在服务端（10.211.55.10）使用<code>nc -l 9999</code> 启动一个 tcp 服务器</p> <div class="language- extra-class"><pre><code>nc -l 9999
</code></pre></div><p>在一台机器（10.211.55.5）记为 c1，使用 tcpdump 抓包开启抓包</p> <div class="language- extra-class"><pre><code>sudo tcpdump -i any port 9999 -nn
</code></pre></div><p>执行下面的 java 代码，往服务端 c2 写 100KB 的数据</p> <div class="language- extra-class"><pre><code>Socket socket = new Socket();
socket.connect(new InetSocketAddress(&quot;c2&quot;, 9999));
OutputStream out = socket.getOutputStream();
byte[] bytes= new byte[100 * 1024];
out.write(bytes);
System.in.read();
</code></pre></div><p>抓包文件显示如下</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73e93840f8d" alt=""></p> <p>可以看到包的长度达到了 14k，远超 MTU 的大小，为什么可以这样呢？</p> <p>这就要说到 TSO（TCP Segment Offload）特性了，TSO 特性是指由网卡代替 CPU 实现 packet 的分段和合并，节省系统资源，因此 TCP 可以抓到超过 MTU 的包，但是不是真正传输的单个包会超过链路的 MTU。</p> <p>使用<code>ethtool -k</code>可以查看这个特性是否打开，比如<code>ethtool -k eth0</code>输出如下</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/3/1700a73ebd4feda9" alt=""></p> <h2 id="tcp-套接字选项-tcp-maxseg"><a href="#tcp-套接字选项-tcp-maxseg" class="header-anchor">#</a> TCP 套接字选项 TCP_MAXSEG</h2> <p>TCP 有一个 socket 选项 TCP_MAXSEG，可以用来设置此次连接的 MSS，如果设置了这个选项，则 MSS 不能超过这个值。我们来看看实际的代码，还是以 echo server 为例，在 bind 之前调用 setsockopt 设置 socket 选项。完整的代码见：<a href="https://github.com/arthur-zhang/tcp-book-code-examples/blob/master/tcp-option-maxseg/test.c" target="_blank" rel="noopener noreferrer">github.com/arthur-zhan…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre><code>int main(int argc, char *argv[]) {
  int port = atoi(argv[1]);
  int mss = atoi(argv[2]);

  // ...
  int tcp_maxseg = mss;
  socklen_t tcp_maxseg_len = sizeof(tcp_maxseg);

  // 设置 TCP_MAXSEG 选项
  if ((err = setsockopt(server_fd, IPPROTO_TCP, TCP_MAXSEG, &amp;tcp_maxseg, tcp_maxseg_len)) &lt; 0) {
    error_quit(&quot;set TCP_MAXSEG failed, code: %d\n&quot;, err);
  }

  if (bind(server_fd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) {
    error_quit(&quot;could not bind socket&quot;);
  }

  if (listen(server_fd, 128) &lt; 0) {
    error_quit(&quot;Could not listen on socket\n&quot;);
  }

  printf(&quot;server start, listening on %d\n&quot;, port);

  while (1) {
    socklen_t client_len = sizeof(cli_addr);

    if ((client_fd = accept(server_fd, (struct sockaddr *)&amp;cli_addr, &amp;client_len)) &lt; 0) {
      error_quit(&quot;could not establish new connection\n&quot;);
    }

    while (1) {
      int read = recv(client_fd, buf, BUFFER_SIZE, 0);
      if (!read) break;
      if (read &lt; 0) error_quit(&quot;read failed\n&quot;);
      if (send(client_fd, buf, read, 0) &lt; 0) error_quit(&quot;write failed\n&quot;);
    }
  }
}
</code></pre></div><p>编译运行上面的代码。</p> <div class="language- extra-class"><pre><code>gcc test.c -o echo-server
./echo-server 9999 100
</code></pre></div><p>在使用 nc 或者 telnet 连接这个 9999 端口服务，使用 tcpdump 查看抓包结果如下。</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/4/17010aaef8da1721" alt=""></p> <p>可以看到经过代码的设置，三次握手中的 MSS 已经从 1460 变为了 100。那 MSS 允许的范围是多少呢？如果设置一个很小的 MSS，比如 50，会出现 setsockopt 失败的情况，如下所示。</p> <div class="language- extra-class"><pre><code>./echo-server 9999 50
set TCP_MAXSEG failed, code: -1
</code></pre></div><p>经过快速的二分法，很快就可以定位出来 setsockopt 合法的范围 88~32767，接下来我们来看看内核对这一部分是如何处理的。内核处理 setsockopt 的函数在 <code>do_tcp_setsockopt@net/ipv4/tcp.c</code>，</p> <div class="language- extra-class"><pre><code>static int do_tcp_setsockopt(struct sock *sk, int level,
		int optname, char __user *optval, unsigned int optlen)
{
    
    switch (optname) {
    case TCP_MAXSEG:
		/* Values greater than interface MTU won't take effect. However
		 * at the point when this call is done we typically don't yet
		 * know which interface is going to be used */
		if (val &lt; TCP_MIN_MSS || val &gt; MAX_TCP_WINDOW) {
			err = -EINVAL; // -22
			break;
		}
		tp-&gt;rx_opt.user_mss = val;
		break;
    }
}
</code></pre></div><p>常量 TCP_MIN_MSS 的值为 88，常量 MAX_TCP_WINDOW 的值为 32768，因此不在 88~32767 直接的 MSS 值会设置失败。</p> <blockquote><p>为什么 TCP_MAXSEG 的下界是 88？</p></blockquote> <p>这是因为 TCP 头包含了 20 字节的固定长度和 40 字节的可选参数，所以 TCP 头的最大长度是 60，IP 头最大长度也是 60。</p> <p>为了保证在 TCP 头占满 60 字节、IP 头占满 60 字节的情况下，至少还能发 8 字节的数据，MSS 至少要等于 (MAX_IP_HDR + MAX_TCP_HDR + MIN_IP_FRAG) - (MIN_IP_HDR + MIN_TCP_HDR) = (60+60+8) - (20+20) = 88 字节。</p> <p>那 MSS 设置一个比较大的值，比如 30000，实际 MSS 是 30000 吗？</p> <p>执行前面的程序，使用 setsockopt 将 MSS 设置为 30000，如下所示。</p> <div class="language- extra-class"><pre><code>./echo-server 9999 30000
</code></pre></div><p>再次在使用 nc 或者 telnet 连接这个 9999 端口服务，使用 tcpdump 查看抓包结果如下。</p> <p><img src="https://user-gold-cdn.xitu.io/2020/2/4/17010aaf0222521f" alt=""></p> <p>可以看到这时 MSS 没有变为 30000，依旧是 1460。这是因为调用 setsockopt 时并不知道后面会使用哪个网卡。后面真正发送 SYN 时，会根据设备的 MTU 重新计算最终的 MSS。</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>这篇文章主要介绍了几个比较基础的概念，IP 数据包长度在超过链路的 MTU 时在发送之前需要分片，而 TCP 层为了 IP 层不用分片主动将包切割成 MSS 大小。</p> <h2 id="作业题"><a href="#作业题" class="header-anchor">#</a> 作业题</h2> <p>1、TCP/IP 协议中，MSS 和 MTU 分别工作在哪一层？</p> <p>2、在 MTU=1500 字节的以太网中，TCP 报文的最大载荷为多少字节？</p> <p><a href="https://juejin.im/book/6844733788681928712/section/6844733788816179207" target="_blank" rel="noopener noreferrer">Source<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html" class="prev">
        5-支撑 TCP 协议的基石 —— 剖析首部字段.md
      </a></span> <span class="next"><a href="/book-docs/tcp-deep-analysis/7-繁忙的贸易港口 —— 聊聊端口号.html">
        7-繁忙的贸易港口 —— 聊聊端口号.md
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/book-docs/tcp-deep-analysis/assets/js/app.c5d1f0fa.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/43.bba7aad7.js" defer></script>
  </body>
</html>
