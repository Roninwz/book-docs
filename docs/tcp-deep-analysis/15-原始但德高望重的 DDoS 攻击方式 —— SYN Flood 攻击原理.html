<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="技术文档">
    
    <link rel="preload" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.1ae38039.css" as="style"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/app.c5d1f0fa.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/13.6eb06c9f.js" as="script"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/10.456c114f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/11.4f919a5c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/12.8691dd56.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/14.8ea58ce4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/15.99b76ce3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/16.892ccdbb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/17.46486d87.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/18.1ae83189.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/19.6788fb0a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/20.38eb4e81.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/21.dd2d7e3c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/22.1fd8c44a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/23.7a6fd38e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/24.4006c26f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/25.acd18f3e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/26.d393a91d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/27.5eb2dc92.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/28.2f7d9a61.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/29.1b6a2c80.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/3.086afb7c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/30.7b2345d3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/31.eec26697.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/32.05263bfb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/33.0a453fe1.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/34.6fcf5c05.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/35.2076a0c2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/36.db825ac9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/37.3ce92f36.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/38.419ced31.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/39.e7e9657a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/4.1e02d683.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/40.11cc02bb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/41.e5c285f2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/42.d1465cb7.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/43.bba7aad7.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/44.c74f481b.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/45.4c2a7d70.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/46.917e2cae.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/47.5ae9bff9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/5.ed3e8199.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/6.19b45fc3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/7.2a1330f4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/8.8683fe45.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/9.b4387ffc.js">
    <link rel="stylesheet" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.1ae38039.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book-docs/tcp-deep-analysis/" class="home-link router-link-active"><!----> <span class="site-name">技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/book-docs/tcp-deep-analysis/1-开篇词 —— 小册食用指南.html" class="sidebar-link">1-开篇词 —— 小册食用指南.md</a></li><li><a href="/book-docs/tcp-deep-analysis/10-聊聊 TCP 自连接那些事.html" class="sidebar-link">10-聊聊 TCP 自连接那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/11-相见时难别亦难 —— 谈谈四次挥手.html" class="sidebar-link">11-相见时难别亦难 —— 谈谈四次挥手.md</a></li><li><a href="/book-docs/tcp-deep-analysis/12-时光机 —— TCP 头部时间戳选项.html" class="sidebar-link">12-时光机 —— TCP 头部时间戳选项.md</a></li><li><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html" class="sidebar-link">13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.md</a></li><li><a href="/book-docs/tcp-deep-analysis/14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.html" class="sidebar-link">14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.md</a></li><li><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html" class="active sidebar-link">15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.md</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html#scapy-工具介绍" class="sidebar-link">Scapy 工具介绍</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html#syn-flood-攻击" class="sidebar-link">SYN flood 攻击</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html#如何应对-syn-flood-攻击" class="sidebar-link">如何应对 SYN Flood 攻击</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html#syn-cookie-机制" class="sidebar-link">SYN Cookie 机制</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/book-docs/tcp-deep-analysis/16-嫌三次握手太慢 —— 来快速打开吧.html" class="sidebar-link">16-嫌三次握手太慢 —— 来快速打开吧.md</a></li><li><a href="/book-docs/tcp-deep-analysis/17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.html" class="sidebar-link">17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.md</a></li><li><a href="/book-docs/tcp-deep-analysis/18-一台主机上两个进程可以同时监听同一个端口吗.html" class="sidebar-link">18-一台主机上两个进程可以同时监听同一个端口吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/19-优雅关闭连接 —— Socket 选项之 SO_LINGER.html" class="sidebar-link">19-优雅关闭连接 —— Socket 选项之 SO_LINGER.md</a></li><li><a href="/book-docs/tcp-deep-analysis/2-TCP_IP 历史与分层模型.html" class="sidebar-link">2-TCP_IP 历史与分层模型.md</a></li><li><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html" class="sidebar-link">20-一个神奇的状态 —— TIME_WAIT.md</a></li><li><a href="/book-docs/tcp-deep-analysis/21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.html" class="sidebar-link">21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.md</a></li><li><a href="/book-docs/tcp-deep-analysis/22-重传机制 —— 超时重传、快速重传与 SACK.html" class="sidebar-link">22-重传机制 —— 超时重传、快速重传与 SACK.md</a></li><li><a href="/book-docs/tcp-deep-analysis/23-重传间隔有讲究 —— 多久重传才合适.html" class="sidebar-link">23-重传间隔有讲究 —— 多久重传才合适.md</a></li><li><a href="/book-docs/tcp-deep-analysis/24-TCP流量控制 —— 滑动窗口.html" class="sidebar-link">24-TCP流量控制 —— 滑动窗口.md</a></li><li><a href="/book-docs/tcp-deep-analysis/25-有风度的 TCP —— 拥塞控制.html" class="sidebar-link">25-有风度的 TCP —— 拥塞控制.md</a></li><li><a href="/book-docs/tcp-deep-analysis/26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.html" class="sidebar-link">26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html" class="sidebar-link">27-TCP 回包的磨叽姐 —— 延迟确认那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/28-兄弟你还活着吗 —— keepalive 原理.html" class="sidebar-link">28-兄弟你还活着吗 —— keepalive 原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html" class="sidebar-link">29-TCP RST 攻击与如何杀掉一条 TCP 连接.md</a></li><li><a href="/book-docs/tcp-deep-analysis/3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.html" class="sidebar-link">3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.md</a></li><li><a href="/book-docs/tcp-deep-analysis/30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.html" class="sidebar-link">30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.md</a></li><li><a href="/book-docs/tcp-deep-analysis/31-定时器一览 —— 细数 TCP 的定时器们.html" class="sidebar-link">31-定时器一览 —— 细数 TCP 的定时器们.md</a></li><li><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html" class="sidebar-link">32-网络工具篇（一） —— telnet、nc、netstat.md</a></li><li><a href="/book-docs/tcp-deep-analysis/33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.html" class="sidebar-link">33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.md</a></li><li><a href="/book-docs/tcp-deep-analysis/34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.html" class="sidebar-link">34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.md</a></li><li><a href="/book-docs/tcp-deep-analysis/35-案例分析 —— JDBC 批量插入真的就批量了吗.html" class="sidebar-link">35-案例分析 —— JDBC 批量插入真的就批量了吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/36-案例分析 —— TCP RST 包导致的网络血案.html" class="sidebar-link">36-案例分析 —— TCP RST 包导致的网络血案.md</a></li><li><a href="/book-docs/tcp-deep-analysis/37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.html" class="sidebar-link">37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.md</a></li><li><a href="/book-docs/tcp-deep-analysis/38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.html" class="sidebar-link">38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/39-作业题和思考题解析.html" class="sidebar-link">39-作业题和思考题解析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/4-来自 Google 的协议栈测试神器 —— packetdrill.html" class="sidebar-link">4-来自 Google 的协议栈测试神器 —— packetdrill.md</a></li><li><a href="/book-docs/tcp-deep-analysis/40-网络学习一路困难，与君共勉.html" class="sidebar-link">40-网络学习一路困难，与君共勉.md</a></li><li><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html" class="sidebar-link">5-支撑 TCP 协议的基石 —— 剖析首部字段.md</a></li><li><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html" class="sidebar-link">6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.md</a></li><li><a href="/book-docs/tcp-deep-analysis/7-繁忙的贸易港口 —— 聊聊端口号.html" class="sidebar-link">7-繁忙的贸易港口 —— 聊聊端口号.md</a></li><li><a href="/book-docs/tcp-deep-analysis/8-临时端口号是如何分配的.html" class="sidebar-link">8-临时端口号是如何分配的.md</a></li><li><a href="/book-docs/tcp-deep-analysis/9-TCP 恋爱史第一步 —— 从三次握手说起.html" class="sidebar-link">9-TCP 恋爱史第一步 —— 从三次握手说起.md</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>有了前面介绍的全连接和半连接队列，理解 SYN Flood 攻击就很简单了。为了模拟 SYN Flood，我们介绍一个新的工具：Scapy。</p> <h2 id="scapy-工具介绍"><a href="#scapy-工具介绍" class="header-anchor">#</a> Scapy 工具介绍</h2> <p>Scapy是一个用 Python 写的强大的交互式数据包处理程序。它可以让用户发送、侦听和解析并伪装网络报文。官网地址：<a href="https://scapy.net/" target="_blank" rel="noopener noreferrer">scapy.net/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> ，安装步骤见官网。</p> <p>安装好以后执行<code>sudo scapy</code>就可以进入一个交互式 shell</p> <div class="language- extra-class"><pre><code>$ sudo scapy
&gt;&gt;&gt;
</code></pre></div><h3 id="发送第一个包"><a href="#发送第一个包" class="header-anchor">#</a> 发送第一个包</h3> <p>在服务器（10.211.55.10）开启 tcpdump 抓包</p> <div class="language- extra-class"><pre><code>sudo tcpdump -i any host 10.211.55.5 -nn
</code></pre></div><p>在客户端（10.211.55.5）启动<code>sudo scapy</code>输入下面的指令</p> <div class="language- extra-class"><pre><code>send(IP(dst=&quot;10.211.55.10&quot;)/ICMP())
.
Sent 1 packets.
</code></pre></div><p>服务端的抓包文件显示服务端收到了客户端的<code>ICMP echo request</code></p> <div class="language- extra-class"><pre><code>06:12:47.466874 IP 10.211.55.5 &gt; 10.211.55.10: ICMP echo request, id 0, seq 0, length 8
06:12:47.466910 IP 10.211.55.10 &gt; 10.211.55.5: ICMP echo reply, id 0, seq 0, length 8
</code></pre></div><h3 id="scapy-构造数据包的方式"><a href="#scapy-构造数据包的方式" class="header-anchor">#</a> scapy 构造数据包的方式</h3> <p>可以看到构造一个数据包非常简单，scapy 采用一个非常简单易懂的方式：<strong>使用<code>/</code>来「堆叠」多个层的数据</strong></p> <p>比如这个例子中的 <code>IP()/ICMP()</code>，如果要用 TCP 发送一段字符串<code>hello, world</code>，就可以这样堆叠：</p> <div class="language- extra-class"><pre><code>IP(src=&quot;10.211.55.99&quot;, dst=&quot;10.211.55.10&quot;) / TCP(sport=9999, dport=80) / &quot;hello, world&quot;
</code></pre></div><p>如果要发送 DNS 查询，可以这样堆叠：</p> <div class="language- extra-class"><pre><code>IP(dst=&quot;8.8.8.8&quot;) / UDP() /DNS(rd=1, qd=DNSQR(qname=&quot;www.baidu.com&quot;))
</code></pre></div><p>如果想拿到返回的结果，可以使用<code>sr</code>（send-receive）函数，与它相关的有一个特殊的函数<code>sr1</code>，只取第一个应答数据包，比如</p> <div class="language- extra-class"><pre><code>&gt;&gt;&gt; res = sr1(IP(dst=&quot;10.211.55.10&quot;)/ICMP())
&gt;&gt;&gt; res
&lt;IP  version=4 ihl=5 tos=0x0 len=28 id=65126 flags= frag=0 ttl=64 proto=icmp chksum=0xf8c5 src=10.211.55.10 dst=10.211.55.5 |&lt;ICMP  type=echo-reply code=0 chksum=0xffff id=0x0 seq=0x0 |&gt;&gt;
</code></pre></div><hr> <h2 id="syn-flood-攻击"><a href="#syn-flood-攻击" class="header-anchor">#</a> SYN flood 攻击</h2> <p>SYN Flood 是一种广为人知的 DoS（拒绝服务攻击） 想象一个场景：客户端大量伪造 IP 发送 SYN 包，服务端回复的 ACK+SYN 去到了一个「未知」的 IP 地址，势必会造成服务端大量的连接处于 SYN_RCVD 状态，而服务器的半连接队列大小也是有限的，如果半连接队列满，也会出现无法处理正常请求的情况。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba36e681b24ff3" alt=""></p> <p>在客户端用 scapy 执行的 sr1 函数向目标机器（10.211.55.5）发起 SYN 包</p> <div class="language- extra-class"><pre><code>sr1(IP(src=&quot;23.16.*.*&quot;, dst=&quot;10.211.55.10&quot;) / TCP(dport=80, flags=&quot;S&quot;) )
</code></pre></div><p>其中服务端收到的 SYN 包的源地址将会是 23.16 网段内的随机 IP，隐藏了自己的 IP。</p> <div class="language- extra-class"><pre><code>netstat -lnpat | grep :80

tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -
tcp        0      0 10.211.55.10:80         23.16.63.3:20           SYN_RECV    -
tcp        0      0 10.211.55.10:80         23.16.64.3:20           SYN_RECV    -
tcp        0      0 10.211.55.10:80         23.16.62.3:20           SYN_RECV    -
</code></pre></div><p>在服务端抓包看到下面的抓包</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba36e689c9cae6" alt=""></p> <p>可以看到短时间内，服务端收到了很多虚假 IP 的 SYN 包，马上回复了 SYN+ACK 给这些虚假 IP 的服务器。这些虚假的 IP 当然一脸懵逼，我都没发 SYN，你给我发 SYN+ACK 干嘛，于是马上回了 RST。</p> <p>使用 netstat 查看服务器的状态</p> <div class="language- extra-class"><pre><code>netstat -lnpat | grep :80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -
tcp        0      0 10.211.55.10:80         23.16.63.3:20           SYN_RECV    -
tcp        0      0 10.211.55.10:80         23.16.64.3:20           SYN_RECV    -
tcp        0      0 10.211.55.10:80         23.16.62.3:20           SYN_RECV    -
</code></pre></div><p>服务端的 SYN_RECV 的数量偶尔涨起来又降下去，因为对端回了 RST 包，这条连接在收到 RST 以后就被从半连接队列清除了。如果攻击者控制了大量的机器，同时发起 SYN，依然会对服务器造成不小的影响。</p> <p>而且 <code>SYN+ACK</code> 去到的不知道是哪里的主机，是否回复 RST 完全取决于它自己，万一它不直接忽略掉 SYN，不回复 RST，问题就更严重了。服务端以为自己的 SYN+ACK 丢失了，会进行重传。</p> <p>我们来模拟一下这种场景。因为没有办法在去 <code>SYN+ACK</code> 包去到的主机的配置，可以在服务器用 iptables 墙掉主机发过来的 RST 包，模拟主机没有回复 RST 包的情况。</p> <div class="language- extra-class"><pre><code>sudo  iptables --append INPUT  --match tcp --protocol tcp --dst 10.211.55.10 --dport 80 --tcp-flags RST RST --jump DROP
</code></pre></div><p>这个时候再次使用 netstat 查看，满屏的 SYN_RECV 出现了</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba36e691c556be" alt=""></p> <p>通过服务端抓包的文件也可以看到，服务端因为 SYN+ACK 丢了，然后进行重传。重传的次数由<code>/proc/sys/net/ipv4/tcp_synack_retries</code>文件决定，在我的 Centos 上这个默认值为 5。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba36e68300ff13" alt=""></p> <p>重传 5 次 SYN+ACK 包，重传的时间依然是指数级退避（1s、2s、4s、8s、16s），发送完最后一次 SYN+ACK 包以后，等待 32s，服务端才会丢弃掉这个连接，把处于SYN_RECV 状态的 socket 关闭。</p> <p>在这种情况下，一次恶意的 SYN 包，会占用一个服务端连接 63s（1+2+4+8+16+32），如果这个时候有大量的恶意 SYN 包过来连接服务器，很快半连接队列就被占满，不能接收正常的用户请求。</p> <h2 id="如何应对-syn-flood-攻击"><a href="#如何应对-syn-flood-攻击" class="header-anchor">#</a> 如何应对 SYN Flood 攻击</h2> <p>常见的有下面这几种方法</p> <h4 id="增加-syn-连接数-tcp-max-syn-backlog"><a href="#增加-syn-连接数-tcp-max-syn-backlog" class="header-anchor">#</a> 增加 SYN 连接数：tcp_max_syn_backlog</h4> <p>调大<code>net.ipv4.tcp_max_syn_backlog</code>的值，不过这只是一个心理安慰，真有攻击的时候，这个再大也不够用。</p> <h4 id="减少syn-ack重试次数-tcp-synack-retries"><a href="#减少syn-ack重试次数-tcp-synack-retries" class="header-anchor">#</a> 减少<code>SYN+ACK</code>重试次数：tcp_synack_retries</h4> <p>重试次数由 <code>/proc/sys/net/ipv4/tcp_synack_retries</code>控制，默认情况下是 5 次，当收到<code>SYN+ACK</code>故意不回 ACK 或者回复的很慢的时候，调小这个值很有必要。</p> <hr> <p>还有一个比较复杂的 tcp_syncookies 机制，下面来详细介绍一下。</p> <h2 id="syn-cookie-机制"><a href="#syn-cookie-机制" class="header-anchor">#</a> SYN Cookie 机制</h2> <p>SYN Cookie 技术最早是在 1996 年提出的，最早就是用来解决 SYN Flood 攻击的，现在服务器上的 tcp_syncookies 都是默认等于 1，表示连接队列满时启用，等于 0 表示禁用，等于 2 表示始终启用。由<code>/proc/sys/net/ipv4/tcp_syncookies</code>控制。</p> <p>SYN Cookie 机制其实原理比较简单，就是在三次握手的最后阶段才分配连接资源，如下图所示。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/29/16ba36e691d04901" alt=""></p> <p>SYN Cookie 的原理是基于「无状态」的机制，服务端收到 SYN 包以后不马上分配为 <code>Inbound SYN</code>分配内存资源，而是根据这个 SYN 包计算出一个 Cookie 值，作为握手第二步的序列号回复 SYN+ACK，等对方回应 ACK 包时校验回复的 ACK 值是否合法，如果合法才三次握手成功，分配连接资源。</p> <p>Cookie 值的计算规则是怎么样的呢？Cookie 总长度是 32bit。这部分的源码见 Linux 源码：<a href="https://github.com/torvalds/linux/blob/79c0ef3e85c015b0921a8fd5dd539d1480e9cd6c/net/ipv4/syncookies.c#L95" target="_blank" rel="noopener noreferrer">syncookies.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre><code>static __u32 secure_tcp_syn_cookie(__be32 saddr, __be32 daddr, __be16 sport,
				   __be16 dport, __u32 sseq, __u32 data)
{
	
	u32 count = tcp_cookie_time(); 
	return (cookie_hash(saddr, daddr, sport, dport, 0, 0) + 
		sseq + 
		 (count &lt;&lt; COOKIEBITS) + 
		((cookie_hash(saddr, daddr, sport, dport, count, 1) + data) 
		 &amp; COOKIEMASK)); 
}
</code></pre></div><p>其中 COOKIEBITS 等于 24，COOKIEMASK 为 低 24 位的掩码，也即 0x00FFFFFF，count 为系统的分钟数，sseq 为客户端传过来的 SEQ 序列号。</p> <p>SYN Cookie 看起来比较完美，但是也有不少的问题。</p> <p>第一，这里的 MSS 值只能是少数的几种，由数组 msstab 值决定</p> <div class="language- extra-class"><pre><code>static __u16 const msstab[] = {
	536,
	1300,
	1440,	
	1460,
};
</code></pre></div><p>第二，因为 syn-cookie 是一个无状态的机制，服务端不保存状态，不能使用其它所有 TCP 选项，比如 WScale，SACK 这些。因此要想变相支持这些选项就得想想其它的偏门，如果启用了 Timestamp 选项，可以把这些值放在 Timestamp 选项值里面。</p> <div class="language- extra-class"><pre><code>+-----------+-------+-------+--------+
|  26 bits  | 1 bit | 1 bit | 4 bits |
| Timestamp |  ECN  | SACK  | WScale |
+-----------+-------+-------+--------+
</code></pre></div><p>不在上面这个四个字段中的扩展选项将无法支持了，如果没有启用 Timestamp 选项，那就彻底凉凉了。</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>这篇文章介绍了用 Scapy 工具构造 SYN Flood 攻击，然后介绍了缓解 SYN Flood 攻击的几种方式，有利有弊，看实际场景启用不同的策略。</p> <p><a href="https://juejin.im/book/6844733788681928712/section/6844733788828729352" target="_blank" rel="noopener noreferrer">Source<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book-docs/tcp-deep-analysis/14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.html" class="prev">
        14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.md
      </a></span> <span class="next"><a href="/book-docs/tcp-deep-analysis/16-嫌三次握手太慢 —— 来快速打开吧.html">
        16-嫌三次握手太慢 —— 来快速打开吧.md
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/book-docs/tcp-deep-analysis/assets/js/app.c5d1f0fa.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/13.6eb06c9f.js" defer></script>
  </body>
</html>
