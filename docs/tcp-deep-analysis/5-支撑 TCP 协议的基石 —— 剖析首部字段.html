<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="技术文档">
    
    <link rel="preload" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.0ea9dfb1.css" as="style"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/app.411d3f03.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/42.e6229e54.js" as="script"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/10.f0096057.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/11.afe0018d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/12.8691dd56.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/13.4570bab2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/14.6bb5eaad.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/15.d523fd97.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/16.be91c86f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/17.4f301f0a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/18.e0b82547.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/19.1c34c4fb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/20.5b297df0.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/21.1e4f6afa.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/22.1fd8c44a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/23.4806d06d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/24.64abf514.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/25.1db6ae87.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/26.79028ade.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/27.49378cc8.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/28.3f365d4e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/29.9e4d2797.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/3.874bed90.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/30.4e5f15e1.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/31.b0e97354.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/32.5ebf2421.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/33.75327db6.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/34.6fcf5c05.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/35.2076a0c2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/36.db825ac9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/37.3ce92f36.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/38.4afa2433.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/39.e7e9657a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/4.0892ecd3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/40.c62d5047.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/41.69a88bf2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/43.e36841dc.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/44.8e5155d3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/45.4c2a7d70.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/46.9ae4ac37.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/47.a075a79f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/5.864d5a79.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/6.19b45fc3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/7.2a1330f4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/8.8683fe45.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/9.c6213155.js">
    <link rel="stylesheet" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.0ea9dfb1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book-docs/tcp-deep-analysis/" class="home-link router-link-active"><!----> <span class="site-name">技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/book-docs/tcp-deep-analysis/1-开篇词 —— 小册食用指南.html" class="sidebar-link">1-开篇词 —— 小册食用指南.md</a></li><li><a href="/book-docs/tcp-deep-analysis/2-TCP_IP 历史与分层模型.html" class="sidebar-link">2-TCP_IP 历史与分层模型.md</a></li><li><a href="/book-docs/tcp-deep-analysis/3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.html" class="sidebar-link">3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.md</a></li><li><a href="/book-docs/tcp-deep-analysis/4-来自 Google 的协议栈测试神器 —— packetdrill.html" class="sidebar-link">4-来自 Google 的协议栈测试神器 —— packetdrill.md</a></li><li><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html" class="active sidebar-link">5-支撑 TCP 协议的基石 —— 剖析首部字段.md</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html#源端口号、目标端口号" class="sidebar-link">源端口号、目标端口号</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html#序列号-sequence-number" class="sidebar-link">序列号（Sequence number）</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html#确认号" class="sidebar-link">确认号</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html#tcp-flags" class="sidebar-link">TCP Flags</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html#窗口大小" class="sidebar-link">窗口大小</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html#可选项" class="sidebar-link">可选项</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html#作业题" class="sidebar-link">作业题</a></li></ul></li><li><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html" class="sidebar-link">6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.md</a></li><li><a href="/book-docs/tcp-deep-analysis/7-繁忙的贸易港口 —— 聊聊端口号.html" class="sidebar-link">7-繁忙的贸易港口 —— 聊聊端口号.md</a></li><li><a href="/book-docs/tcp-deep-analysis/8-临时端口号是如何分配的.html" class="sidebar-link">8-临时端口号是如何分配的.md</a></li><li><a href="/book-docs/tcp-deep-analysis/9-TCP 恋爱史第一步 —— 从三次握手说起.html" class="sidebar-link">9-TCP 恋爱史第一步 —— 从三次握手说起.md</a></li><li><a href="/book-docs/tcp-deep-analysis/10-聊聊 TCP 自连接那些事.html" class="sidebar-link">10-聊聊 TCP 自连接那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/11-相见时难别亦难 —— 谈谈四次挥手.html" class="sidebar-link">11-相见时难别亦难 —— 谈谈四次挥手.md</a></li><li><a href="/book-docs/tcp-deep-analysis/12-时光机 —— TCP 头部时间戳选项.html" class="sidebar-link">12-时光机 —— TCP 头部时间戳选项.md</a></li><li><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html" class="sidebar-link">13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.md</a></li><li><a href="/book-docs/tcp-deep-analysis/14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.html" class="sidebar-link">14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.md</a></li><li><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html" class="sidebar-link">15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/16-嫌三次握手太慢 —— 来快速打开吧.html" class="sidebar-link">16-嫌三次握手太慢 —— 来快速打开吧.md</a></li><li><a href="/book-docs/tcp-deep-analysis/17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.html" class="sidebar-link">17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.md</a></li><li><a href="/book-docs/tcp-deep-analysis/18-一台主机上两个进程可以同时监听同一个端口吗.html" class="sidebar-link">18-一台主机上两个进程可以同时监听同一个端口吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/19-优雅关闭连接 —— Socket 选项之 SO_LINGER.html" class="sidebar-link">19-优雅关闭连接 —— Socket 选项之 SO_LINGER.md</a></li><li><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html" class="sidebar-link">20-一个神奇的状态 —— TIME_WAIT.md</a></li><li><a href="/book-docs/tcp-deep-analysis/21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.html" class="sidebar-link">21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.md</a></li><li><a href="/book-docs/tcp-deep-analysis/22-重传机制 —— 超时重传、快速重传与 SACK.html" class="sidebar-link">22-重传机制 —— 超时重传、快速重传与 SACK.md</a></li><li><a href="/book-docs/tcp-deep-analysis/23-重传间隔有讲究 —— 多久重传才合适.html" class="sidebar-link">23-重传间隔有讲究 —— 多久重传才合适.md</a></li><li><a href="/book-docs/tcp-deep-analysis/24-TCP流量控制 —— 滑动窗口.html" class="sidebar-link">24-TCP流量控制 —— 滑动窗口.md</a></li><li><a href="/book-docs/tcp-deep-analysis/25-有风度的 TCP —— 拥塞控制.html" class="sidebar-link">25-有风度的 TCP —— 拥塞控制.md</a></li><li><a href="/book-docs/tcp-deep-analysis/26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.html" class="sidebar-link">26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html" class="sidebar-link">27-TCP 回包的磨叽姐 —— 延迟确认那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/28-兄弟你还活着吗 —— keepalive 原理.html" class="sidebar-link">28-兄弟你还活着吗 —— keepalive 原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html" class="sidebar-link">29-TCP RST 攻击与如何杀掉一条 TCP 连接.md</a></li><li><a href="/book-docs/tcp-deep-analysis/30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.html" class="sidebar-link">30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.md</a></li><li><a href="/book-docs/tcp-deep-analysis/31-定时器一览 —— 细数 TCP 的定时器们.html" class="sidebar-link">31-定时器一览 —— 细数 TCP 的定时器们.md</a></li><li><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html" class="sidebar-link">32-网络工具篇（一） —— telnet、nc、netstat.md</a></li><li><a href="/book-docs/tcp-deep-analysis/33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.html" class="sidebar-link">33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.md</a></li><li><a href="/book-docs/tcp-deep-analysis/34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.html" class="sidebar-link">34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.md</a></li><li><a href="/book-docs/tcp-deep-analysis/35-案例分析 —— JDBC 批量插入真的就批量了吗.html" class="sidebar-link">35-案例分析 —— JDBC 批量插入真的就批量了吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/36-案例分析 —— TCP RST 包导致的网络血案.html" class="sidebar-link">36-案例分析 —— TCP RST 包导致的网络血案.md</a></li><li><a href="/book-docs/tcp-deep-analysis/37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.html" class="sidebar-link">37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.md</a></li><li><a href="/book-docs/tcp-deep-analysis/38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.html" class="sidebar-link">38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/39-作业题和思考题解析.html" class="sidebar-link">39-作业题和思考题解析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/40-网络学习一路困难，与君共勉.html" class="sidebar-link">40-网络学习一路困难，与君共勉.md</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>这篇文章来讲讲 TCP 报文首部相关的概念，这些头部是支撑 TCP 复杂功能的基石。 完整的 TCP 头部如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d702629b61cbcc" alt=""></p> <p>我们用一次访问百度网页抓包的例子来开始。</p> <div class="language- extra-class"><pre><code>curl -v www.baidu.com
</code></pre></div><p>完整的抓包文件可以来 github 下载：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_header/curl_baidu.pcapng" target="_blank" rel="noopener noreferrer">curl_baidu.pcapng<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d702629babb3f6" alt=""></p> <h2 id="源端口号、目标端口号"><a href="#源端口号、目标端口号" class="header-anchor">#</a> 源端口号、目标端口号</h2> <p>在第一个包的详情中，首先看到的高亮部分的源端口号（Src Port）和目标端口号（Dst Port)，这个例子中本地源端口号为 61024，百度目标端口号是 80。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70262f5e8a192" alt=""></p> <p>TCP 报文头部里没有源 ip 和目标 ip 地址，只有源端口号和目标端口号</p> <p>这也是初学 wireshark 抓包时很多人会有的一个疑问：过滤 ip 地址为 172.19.214.24 包的条件为什么不是 &quot;tcp.addr == 172.19.214.24&quot;，而是 &quot;ip.addr == 172.19.214.24&quot;</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70262f65563ce" alt=""></p> <p>TCP 的报文里是没有源 ip 和目标 ip 的，因为那是 IP 层协议的事情，TCP 层只有源端口和目标端口。</p> <p>源 IP、源端口、目标 IP、目标端口构成了 TCP 连接的「四元组」。一个四元组可以唯一标识一个连接。</p> <p>后面文章中专门有一节是用来介绍端口号相关的知识。</p> <hr> <p>接下来，我们看到的是序列号，如截图中 2 的标识。</p> <h2 id="序列号-sequence-number"><a href="#序列号-sequence-number" class="header-anchor">#</a> 序列号（Sequence number）</h2> <p>TCP 是面向字节流的协议，通过 TCP 传输的字节流的每个字节都分配了序列号，序列号（Sequence number）指的是本报文段第一个字节的序列号。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70262f7fb618a" alt=""></p> <p>序列号加上报文的长度，就可以确定传输的是哪一段数据。序列号是一个 32 位的无符号整数，达到 2^32-1 后循环到 0。</p> <p>在 SYN 报文中，序列号用于交换彼此的初始序列号，在其它报文中，序列号用于保证包的顺序。</p> <p>因为网络层（IP 层）不保证包的顺序，TCP 协议利用序列号来解决网络包乱序、重复的问题，以保证数据包以正确的顺序组装传递给上层应用。</p> <p>如果发送方发送的是四个报文序列号分别是1、2、3、4，但到达接收方的顺序是 2、4、3、1，接收方就可以通过序列号的大小顺序组装出原始的数据。</p> <h3 id="初始序列号-initial-sequence-number-isn"><a href="#初始序列号-initial-sequence-number-isn" class="header-anchor">#</a> 初始序列号（Initial Sequence Number, ISN）</h3> <p>在建立连接之初，通信双方都会各自选择一个序列号，称之为初始序列号。在建立连接时，通信双方通过 SYN 报文交换彼此的 ISN，如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70264eaa6828c" alt=""></p> <p>初始建立连接的过程中 SYN 报文交换过程如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70264ef144241" alt=""></p> <p>其中第 2 步和第 3 步可以合并一起，这就是三次握手的过程</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70264f4692792" alt=""></p> <h3 id="初始序列号是如何生成的"><a href="#初始序列号是如何生成的" class="header-anchor">#</a> 初始序列号是如何生成的</h3> <div class="language- extra-class"><pre><code>__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	u32 hash[MD5_DIGEST_WORDS];

	net_secret_init();
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport &lt;&lt; 16) + (__force u16)dport;
	hash[3] = net_secret[15];
	
	md5_transform(hash, net_secret);

	return seq_scale(hash[0]);
}

static u32 seq_scale(u32 seq)
{
	return seq + (ktime_to_ns(ktime_get_real()) &gt;&gt; 6);
}
</code></pre></div><p>代码中的 net_secret 是一个长度为 16 的 int 数组，只有在第一次调用 net_secret_init 的时时候会将将这个数组的值初始化为随机值。在系统重启前保持不变。</p> <p>可以看到初始序列号的计算函数 secure_tcp_sequence_number() 的逻辑是通过源地址、目标地址、源端口、目标端口和随机因子通过 MD5 进行进行计算。如果仅有这几个因子，对于四元组相同的请求，计算出的初始序列号总是相同，这必然有很大的安全风险，所以函数的最后将计算出的序列号通过 seq_scale 函数再次计算。</p> <p>seq_scale 函数加入了时间因子，对于四元组相同的连接，序列号也不会重复了。</p> <h3 id="序列号回绕了怎么处理"><a href="#序列号回绕了怎么处理" class="header-anchor">#</a> 序列号回绕了怎么处理</h3> <p>序列号是一个 32 位的无符号整数，从前面介绍的初始序列号计算算法可以知道，ISN 并不是从 0 开始，所以同一个连接的序列号是有可能溢出回绕（sequence wraparound）的。TCP 的很多校验比如丢包、乱序判断都是通过比较包的序号来实现的，我们来看看 linux 内核是如何处理的，代码如下所示。</p> <div class="language- extra-class"><pre><code>static inline bool before(__u32 seq1, __u32 seq2)
{
        return (__s32)(seq1-seq2) &lt; 0;
}
</code></pre></div><p>其中 <code>__u32</code> 表示无符号的 32 位整数，<code>__s32</code> 表示有符号的 32 位整数。为什么 seq1 - seq2 转为有符号的 32 位整数就可以判断 seq1 和 seq2 的大小了呢？</p> <p>以 seq1 为 0xFFFFFFFF、seq2 为 0x02（回绕）为例，它们相减的结果如下。</p> <div class="language- extra-class"><pre><code>seq1 - seq2 = 0xFFFFFFFF - 0x02 = 0xFFFFFFFD
</code></pre></div><p>0xFFFFFFFD 最高位为 1，表示为负数，实际值为 -(0x00000002 + 1) = -3，这样即使 seq2 回绕了，也可以知道 seq1&lt;seq2。</p> <hr> <h2 id="确认号"><a href="#确认号" class="header-anchor">#</a> 确认号</h2> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70265e2c9f7c0" alt=""></p> <p>TCP 使用确认号（Acknowledgment number, ACK）来告知对方下一个期望接收的序列号，小于此确认号的所有字节都已经收到。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70265e3d247b3" alt=""></p> <p>关于确认号有几个注意点：</p> <ul><li>不是所有的包都需要确认的</li> <li>不是收到了数据包就立马需要确认的，可以延迟一会再确认</li> <li>ACK 包本身不需要被确认，否则就会无穷无尽死循环了</li> <li>确认号永远是表示小于此确认号的字节都已经收到</li></ul> <h2 id="tcp-flags"><a href="#tcp-flags" class="header-anchor">#</a> TCP Flags</h2> <p>TCP 有很多种标记，有些用来发起连接同步初始序列号，有些用来确认数据包，还有些用来结束连接。TCP 定义了一个 8 位的字段用来表示 flags，大部分都只用到了后 6 个，如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70265e3ed0a23" alt=""></p> <p>下面这个是 wireshark 第一个 SYN 包的 flags 截图</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70266d81f6e83" alt=""></p> <p>我们通常所说的 SYN、ACK、FIN、RST 其实只是把 flags 对应的 bit 位置为 1 而已，这些标记可以组合使用，比如 SYN+ACK，FIN+ACK 等</p> <p>最常见的有下面这几个：</p> <ul><li>SYN（Synchronize）：用于发起连接数据包同步双方的初始序列号</li> <li>ACK（Acknowledge）：确认数据包</li> <li>RST（Reset）：这个标记用来强制断开连接，通常是之前建立的连接已经不在了、包不合法、或者实在无能为力处理</li> <li>FIN（Finish）：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了。</li> <li>PSH（Push）：告知对方这些数据包收到以后应该马上交给上层应用，不能缓存起来</li></ul> <h2 id="窗口大小"><a href="#窗口大小" class="header-anchor">#</a> 窗口大小</h2> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70266d82aaebd" alt=""></p> <p>可以看到用于表示窗口大小的&quot;Window Size&quot; 只有 16 位，可能 TCP 协议设计者们认为 16 位的窗口大小已经够用了，也就是最大窗口大小是 65535 字节（64KB）。就像网传盖茨曾经说过：“640K内存对于任何人来说都足够了”一样。</p> <p>自己挖的坑当然要自己填，因此TCP 协议引入了「TCP 窗口缩放」选项 作为窗口缩放的比例因子，比例因子值的范围是 0 ~ 14，其中最小值 0 表示不缩放，最大值 14。比例因子可以将窗口扩大到原来的 2 的 n 次方，比如窗口大小缩放前为 1050，缩放因子为 7，则真正的窗口大小为 1050 * 128 = 134400，如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70266db317004" alt=""></p> <p>在 wireshark 中最终的窗口大小会自动计算出来，如下图中的 Calculated window size。以本文中抓包的例子为例</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70266f7f45c6b" alt=""></p> <p>值得注意的是，窗口缩放值在三次握手的时候指定，如果抓包的时候没有抓到 SYN 包，wireshark 是不知道真正的窗口缩放值是多少的。</p> <h2 id="可选项"><a href="#可选项" class="header-anchor">#</a> 可选项</h2> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70266f7d32a0f" alt=""></p> <p>可选项的格式入下所示</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d70266f820427e" alt=""></p> <p>以 MSS 为例，kind=2，length=4，value=1460</p> <p><img src="https://user-gold-cdn.xitu.io/2019/9/27/16d7026733bbfa60" alt=""></p> <p>常用的选项有以下几个：</p> <ul><li>MSS：最大段大小选项，是 TCP 允许的从对方接收的最大报文段</li> <li>SACK：选择确认选项</li> <li>Window Scale：窗口缩放选项</li></ul> <h2 id="作业题"><a href="#作业题" class="header-anchor">#</a> 作业题</h2> <p>1、如果一个 TCP 连接正在传送 5000 字节的数据，第一个字节的序号是 10001，数据被分为 5 段，每个段携带 1000 字节，请问每个段的序号是什么？</p> <p>2、A B 两个主机之间建立了一个 TCP 连接，A 主机发给 B 主机两个 TCP 报文，大小分别是 500 和 300，第一个报文的序列号是 200，那么 B 主机接收两个报文后，返回的确认号是（）</p> <ul><li>A、200</li> <li>B、700</li> <li>C、800</li> <li>D、1000</li></ul> <p>3、客户端的使用 ISN=2000 打开一个连接，服务器端使用 ISN=3000 打开一个连接，经过 3 次握手建立连接。连接建立起来以后，假定客户端向服务器发送一段数据<code>Welcome the server!</code>（长度 20 Bytes），而服务器的回答数据<code>Thank you!</code>（长度 10 Bytes ），试画出三次握手和数据传输阶段报文段序列号、确认号的情况。</p> <p><a href="https://juejin.im/book/6844733788681928712/section/6844733788816162823" target="_blank" rel="noopener noreferrer">Source<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book-docs/tcp-deep-analysis/4-来自 Google 的协议栈测试神器 —— packetdrill.html" class="prev">
        4-来自 Google 的协议栈测试神器 —— packetdrill.md
      </a></span> <span class="next"><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html">
        6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.md
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/book-docs/tcp-deep-analysis/assets/js/app.411d3f03.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/42.e6229e54.js" defer></script>
  </body>
</html>
