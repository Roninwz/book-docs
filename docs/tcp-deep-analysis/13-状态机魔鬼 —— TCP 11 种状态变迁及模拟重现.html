<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="技术文档">
    
    <link rel="preload" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.1ae38039.css" as="style"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/app.c5d1f0fa.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/11.4f919a5c.js" as="script"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/10.456c114f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/12.8691dd56.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/13.6eb06c9f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/14.8ea58ce4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/15.99b76ce3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/16.892ccdbb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/17.46486d87.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/18.1ae83189.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/19.6788fb0a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/20.38eb4e81.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/21.dd2d7e3c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/22.1fd8c44a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/23.7a6fd38e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/24.4006c26f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/25.acd18f3e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/26.d393a91d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/27.5eb2dc92.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/28.2f7d9a61.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/29.1b6a2c80.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/3.086afb7c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/30.7b2345d3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/31.eec26697.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/32.05263bfb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/33.0a453fe1.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/34.6fcf5c05.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/35.2076a0c2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/36.db825ac9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/37.3ce92f36.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/38.419ced31.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/39.e7e9657a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/4.1e02d683.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/40.11cc02bb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/41.e5c285f2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/42.d1465cb7.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/43.bba7aad7.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/44.c74f481b.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/45.4c2a7d70.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/46.917e2cae.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/47.5ae9bff9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/5.ed3e8199.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/6.19b45fc3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/7.2a1330f4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/8.8683fe45.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/9.b4387ffc.js">
    <link rel="stylesheet" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.1ae38039.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book-docs/tcp-deep-analysis/" class="home-link router-link-active"><!----> <span class="site-name">技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/book-docs/tcp-deep-analysis/1-开篇词 —— 小册食用指南.html" class="sidebar-link">1-开篇词 —— 小册食用指南.md</a></li><li><a href="/book-docs/tcp-deep-analysis/10-聊聊 TCP 自连接那些事.html" class="sidebar-link">10-聊聊 TCP 自连接那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/11-相见时难别亦难 —— 谈谈四次挥手.html" class="sidebar-link">11-相见时难别亦难 —— 谈谈四次挥手.md</a></li><li><a href="/book-docs/tcp-deep-analysis/12-时光机 —— TCP 头部时间戳选项.html" class="sidebar-link">12-时光机 —— TCP 头部时间戳选项.md</a></li><li><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html" class="active sidebar-link">13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.md</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html#_11、closing" class="sidebar-link">11、CLOSING</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html#小结" class="sidebar-link">小结</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html#作业题" class="sidebar-link">作业题</a></li></ul></li><li><a href="/book-docs/tcp-deep-analysis/14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.html" class="sidebar-link">14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.md</a></li><li><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html" class="sidebar-link">15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/16-嫌三次握手太慢 —— 来快速打开吧.html" class="sidebar-link">16-嫌三次握手太慢 —— 来快速打开吧.md</a></li><li><a href="/book-docs/tcp-deep-analysis/17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.html" class="sidebar-link">17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.md</a></li><li><a href="/book-docs/tcp-deep-analysis/18-一台主机上两个进程可以同时监听同一个端口吗.html" class="sidebar-link">18-一台主机上两个进程可以同时监听同一个端口吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/19-优雅关闭连接 —— Socket 选项之 SO_LINGER.html" class="sidebar-link">19-优雅关闭连接 —— Socket 选项之 SO_LINGER.md</a></li><li><a href="/book-docs/tcp-deep-analysis/2-TCP_IP 历史与分层模型.html" class="sidebar-link">2-TCP_IP 历史与分层模型.md</a></li><li><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html" class="sidebar-link">20-一个神奇的状态 —— TIME_WAIT.md</a></li><li><a href="/book-docs/tcp-deep-analysis/21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.html" class="sidebar-link">21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.md</a></li><li><a href="/book-docs/tcp-deep-analysis/22-重传机制 —— 超时重传、快速重传与 SACK.html" class="sidebar-link">22-重传机制 —— 超时重传、快速重传与 SACK.md</a></li><li><a href="/book-docs/tcp-deep-analysis/23-重传间隔有讲究 —— 多久重传才合适.html" class="sidebar-link">23-重传间隔有讲究 —— 多久重传才合适.md</a></li><li><a href="/book-docs/tcp-deep-analysis/24-TCP流量控制 —— 滑动窗口.html" class="sidebar-link">24-TCP流量控制 —— 滑动窗口.md</a></li><li><a href="/book-docs/tcp-deep-analysis/25-有风度的 TCP —— 拥塞控制.html" class="sidebar-link">25-有风度的 TCP —— 拥塞控制.md</a></li><li><a href="/book-docs/tcp-deep-analysis/26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.html" class="sidebar-link">26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html" class="sidebar-link">27-TCP 回包的磨叽姐 —— 延迟确认那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/28-兄弟你还活着吗 —— keepalive 原理.html" class="sidebar-link">28-兄弟你还活着吗 —— keepalive 原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html" class="sidebar-link">29-TCP RST 攻击与如何杀掉一条 TCP 连接.md</a></li><li><a href="/book-docs/tcp-deep-analysis/3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.html" class="sidebar-link">3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.md</a></li><li><a href="/book-docs/tcp-deep-analysis/30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.html" class="sidebar-link">30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.md</a></li><li><a href="/book-docs/tcp-deep-analysis/31-定时器一览 —— 细数 TCP 的定时器们.html" class="sidebar-link">31-定时器一览 —— 细数 TCP 的定时器们.md</a></li><li><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html" class="sidebar-link">32-网络工具篇（一） —— telnet、nc、netstat.md</a></li><li><a href="/book-docs/tcp-deep-analysis/33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.html" class="sidebar-link">33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.md</a></li><li><a href="/book-docs/tcp-deep-analysis/34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.html" class="sidebar-link">34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.md</a></li><li><a href="/book-docs/tcp-deep-analysis/35-案例分析 —— JDBC 批量插入真的就批量了吗.html" class="sidebar-link">35-案例分析 —— JDBC 批量插入真的就批量了吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/36-案例分析 —— TCP RST 包导致的网络血案.html" class="sidebar-link">36-案例分析 —— TCP RST 包导致的网络血案.md</a></li><li><a href="/book-docs/tcp-deep-analysis/37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.html" class="sidebar-link">37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.md</a></li><li><a href="/book-docs/tcp-deep-analysis/38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.html" class="sidebar-link">38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/39-作业题和思考题解析.html" class="sidebar-link">39-作业题和思考题解析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/4-来自 Google 的协议栈测试神器 —— packetdrill.html" class="sidebar-link">4-来自 Google 的协议栈测试神器 —— packetdrill.md</a></li><li><a href="/book-docs/tcp-deep-analysis/40-网络学习一路困难，与君共勉.html" class="sidebar-link">40-网络学习一路困难，与君共勉.md</a></li><li><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html" class="sidebar-link">5-支撑 TCP 协议的基石 —— 剖析首部字段.md</a></li><li><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html" class="sidebar-link">6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.md</a></li><li><a href="/book-docs/tcp-deep-analysis/7-繁忙的贸易港口 —— 聊聊端口号.html" class="sidebar-link">7-繁忙的贸易港口 —— 聊聊端口号.md</a></li><li><a href="/book-docs/tcp-deep-analysis/8-临时端口号是如何分配的.html" class="sidebar-link">8-临时端口号是如何分配的.md</a></li><li><a href="/book-docs/tcp-deep-analysis/9-TCP 恋爱史第一步 —— 从三次握手说起.html" class="sidebar-link">9-TCP 恋爱史第一步 —— 从三次握手说起.md</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>讲完前面建立连接、断开连接的过程，整个 TCP 协议的 11 种状态都出现了。TCP 之所以复杂，是因为它是一个有状态的协议。如果这个时候祭出下面的 TCP 状态变化图，估计大多数人都会懵圈，不要慌，我们会把上面的状态一一解释清楚。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/22/16b7c9fb02bff057" alt=""></p> <p>上面这个图是网络上有人用 Latex 画出来了，很赞。不过有一处小错误，我修改了一下，如果感兴趣的话可以从我的 github 上进行下载，链接：<a href="https://github.com/arthur-zhang/tcp_ebook/tree/master/tcp_connection_management" target="_blank" rel="noopener noreferrer">tcp-state-machine.tex<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，在 <a href="https://www.overleaf.com/" target="_blank" rel="noopener noreferrer">overleaf<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的网站可以进行实时预览。</p> <p><strong>1、CLOSED</strong></p> <p>这个状态是一个「假想」的状态，是 TCP 连接还未开始建立连接或者连接已经彻底释放的状态。因此<code>CLOSED</code>状态也无法通过 <code>netstat</code> 或者 <code>lsof</code> 等工具看到。</p> <p>从图中可以看到，从 CLOSE 状态转换为其它状态有两种可能：主动打开（Active Open）和被动打开（Passive Open）</p> <ul><li>被动打开：一般来说，服务端会监听一个特定的端口，等待客户端的新连接，同时会进入<code>LISTEN</code>状态，这种被称为「被动打开」</li> <li>主动打开：客户端主动发送一个<code>SYN</code>包准备三次握手，被称为「主动打开（Active Open）」</li></ul> <p><strong>2、LISTEN</strong></p> <p>一端（通常是服务端）调用 bind、listen 系统调用监听特定端口时进入到<code>LISTEN</code>状态，等待客户端发送 <code>SYN</code> 报文三次握手建立连接。</p> <p>在 Java 中只用一行代码就可以构造一个 listen 状态的 socket。</p> <div class="language- extra-class"><pre><code>ServerSocket serverSocket = new ServerSocket(9999);
</code></pre></div><p>ServerSocket 的构造器函数最终调用了 bind、listen，接下来就可以调用 accept 接收客户端连接请求了。</p> <p>使用 netstat 进行查看</p> <div class="language- extra-class"><pre><code>netstat -tnpa | grep -i 9999                     
tcp6       0      0 :::9999     :::*                    LISTEN      20096/java       
</code></pre></div><p>处于<code>LISTEN</code>状态的连接收到<code>SYN</code>包以后会发送 <code>SYN+ACK</code> 给对端，同时进入<code>SYN-RCVD</code>阶段</p> <p><strong>3、SYN-SENT</strong></p> <p>客户端发送 <code>SYN</code> 报文等待 <code>ACK</code> 的过程进入 <code>SYN-SENT</code>状态。同时会开启一个定时器，如果超时还没有收到<code>ACK</code>会重发 SYN。</p> <p>使用 packetdrill 可以非常快速的构造一个处于<code>SYN-SENT</code>状态的连接，完整的代码见：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_state/syn_sent.pkt" target="_blank" rel="noopener noreferrer">syn_sent.pkt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre><code>+0 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3
</code></pre></div><p>​<br>
+0 connect(3, ..., ...) = -1</p> <p>运行上面的脚本，然后使用 netstat 命令查看连接状态l</p> <div class="language- extra-class"><pre><code>netstat -atnp | grep -i 8080                                                                                                    
tcp        0      1 192.168.46.26:42678     192.0.2.1:8080          SYN_SENT    3897/packetdrill
</code></pre></div><p><strong>4、SYN-RCVD</strong></p> <p>服务端收到<code>SYN</code>报文以后会回复 <code>SYN+ACK</code>，然后等待对端 ACK 的时候进入<code>SYN-RCVD</code>，完整的代码见：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_state/state_syn_rcvd.pkt" target="_blank" rel="noopener noreferrer">state_syn_rcvd.pkt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre><code>+0  &lt; S 0:0(0) win 65535  &lt;mss 100&gt;
+0  &gt; S. 0:0(0) ack 1 &lt;...&gt;
// 故意注释掉下面这一行
// +.1 &lt; . 1:1(0) ack 1 win 65535
</code></pre></div><p><strong>5、ESTABLISHED</strong></p> <p><code>SYN-SENT</code>或者<code>SYN-RCVD</code>状态的连接收到对端确认<code>ACK</code>以后进入<code>ESTABLISHED</code>状态，连接建立成功。</p> <p>把上面例子中脚本的注释取消掉，三次握手成功就会进入<code>ESTABLISHED</code>状态。</p> <p>从图中可以看到<code>ESTABLISHED</code>状态的连接有两种可能的状态转换方式:</p> <ul><li>调用 close 等系统调用主动关闭连接，这个时候会发送 FIN 包给对端，同时自己进入<code>FIN-WAIT-1</code>状态</li> <li>收到对端的 FIN 包，执行被动关闭，收到 <code>FIN</code> 包以后会回复 <code>ACK</code>，同时自己进入<code>CLOSE-WAIT</code>状态</li></ul> <p><strong>6、FIN-WAIT-1</strong></p> <p>主动关闭的一方发送了 FIN 包，等待对端回复 ACK 时进入<code>FIN-WAIT-1</code>状态。</p> <p>模拟的 packetdrill 脚本见：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_state/state_fin_wait_1.pkt" target="_blank" rel="noopener noreferrer">state_fin_wait_1.pkt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre><code>+0  &lt; S 0:0(0) win 65535  &lt;mss 100&gt;
+0  &gt; S. 0:0(0) ack 1 &lt;...&gt;
.1 &lt; . 1:1(0) ack 1 win 65535

+.1 accept(3, ..., ...) = 4
</code></pre></div><p>​<br>
+.1 close(4) = 0</p> <p>执行上的脚本，使用 netstat 就可以看到 FIN_WAIT1 状态的连接了</p> <div class="language- extra-class"><pre><code>netstat -tnpa | grep 8080
tcp        0      0 192.168.73.207:8080     0.0.0.0:*               LISTEN      -                   
tcp        0      1 192.168.73.207:8080     192.0.2.1:52859         FIN_WAIT1   -   
</code></pre></div><p><code>FIN_WAIT1</code>状态的切换如下几种情况</p> <ul><li>当收到 <code>ACK</code> 以后，<code>FIN-WAIT-1</code>状态会转换到<code>FIN-WAIT-2</code>状态</li> <li>当收到 <code>FIN</code> 以后，会回复对端 <code>ACK</code>，<code>FIN-WAIT-1</code>状态会转换到<code>CLOSING</code>状态</li> <li>当收到 <code>FIN+ACK</code> 以后，会回复对端 <code>ACK</code>，<code>FIN-WAIT-1</code>状态会转换到<code>TIME_WAIT</code>状态，跳过了<code>FIN-WAIT-2</code>状态</li></ul> <p><strong>7、FIN-WAIT-2</strong></p> <p>处于 <code>FIN-WAIT-1</code>状态的连接收到 ACK 确认包以后进入<code>FIN-WAIT-2</code>状态，这个时候主动关闭方的 FIN 包已经被对方确认，等待被动关闭方发送 FIN 包。</p> <p>模拟的脚本见：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_state/state_fin_wait_2.pkt" target="_blank" rel="noopener noreferrer">state_fin_wait_2.pkt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，核心代码如下</p> <div class="language- extra-class"><pre><code>+0  &lt; S 0:0(0) win 65535  &lt;mss 100&gt;
+0  &gt; S. 0:0(0) ack 1 &lt;...&gt;
.1 &lt; . 1:1(0) ack 1 win 65535
+.1  accept(3, ..., ...) = 4
</code></pre></div><p>​<br>
+.1 close(4) = 0</p> <p>​<br>
+.1 &lt; . 1:1(0) ack 2 win 257</p> <p>执行上的脚本，使用 netstat 就可以看到 FIN_WAIT2 状态的连接了</p> <div class="language- extra-class"><pre><code>netstat -tnpa | grep 8080
tcp        0      0 192.168.81.69:8080      0.0.0.0:*               LISTEN      -                   
tcp        0      0 192.168.81.69:8080      192.0.2.1:34131         FIN_WAIT2   -  
</code></pre></div><p>当收到对端的 FIN 包以后，主动关闭方进入<code>TIME_WAIT</code>状态</p> <p><strong>8、CLOSE-WAIT</strong></p> <p>当有一方想关闭连接的时候，调用 close 等系统调用关闭 TCP 连接会发送 FIN 包给对端，这个被动关闭方，收到 FIN 包以后进入<code>CLOSE-WAIT</code>状态。</p> <p>完整的代码见：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_state/state_close_wait.pkt" target="_blank" rel="noopener noreferrer">state_close_wait.pkt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre><code>+.1 &lt; F. 1:1(0) win 65535  &lt;mss 100&gt; 

+0 &gt; . 1:1(0) ack 2 &lt;...&gt;
</code></pre></div><p>执行上的脚本，使用 netstat 就可以看到 CLOSE_WAIT 状态的连接了</p> <div class="language- extra-class"><pre><code>sudo netstat -tnpa | grep -i 8080    
tcp        0      0 192.168.168.15:8080     0.0.0.0:*               LISTEN      15818/packetdrill   
tcp        1      0 192.168.168.15:8080     192.0.2.1:44948         CLOSE_WAIT  15818/packetdrill   
</code></pre></div><p>当被动关闭方有数据要发送给对端的时候，可以继续发送数据。当没有数据发送给对方时，也会调用 close 等系统调用关闭 TCP 连接，发送 FIN 包给主动关闭的一方，同时进入<code>LAST-ACK</code>状态</p> <p><strong>9、TIME-WAIT</strong></p> <p><code>TIME-WAIT</code>可能是所有状态中面试问的最频繁的一种状态了。这个状态是收到了被动关闭方的 FIN 包，发送确认 ACK 给对端，开启 2MSL 定时器，定时器到期时进入 <code>CLOSED</code> 状态，连接释放。<code>TIME-WAIT</code> 会有专门的文章介绍。</p> <p>完整的代码见：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_state/state_time_wait.pkt" target="_blank" rel="noopener noreferrer">state_time_wait.pkt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre><code>// 服务端主动断开连接
+.1 close(4) = 0
+0 &gt; F. 1:1(0) ack 1 &lt;...&gt;

// 向协议栈注入 ACK 包，模拟客户端发送了 ACK
+.1 &lt; . 1:1(0) ack 2 win 257

// 向协议栈注入 FIN，模拟服务端收到了 FIN
+.1 &lt; F. 1:1(0) win 65535  &lt;mss 100&gt; 

+0 `sleep 1000000`
</code></pre></div><p>执行上的脚本，使用 netstat 就可以看到 TIME-WAIT 状态的连接了</p> <div class="language- extra-class"><pre><code>netstat -tnpa | grep -i 8080

tcp        0      0 192.168.210.245:8080    0.0.0.0:*               LISTEN      6297/packetdrill    
tcp        0      0 192.168.210.245:8080    192.0.2.1:40091         TIME_WAIT   -  
</code></pre></div><p><strong>10、LAST-ACK</strong></p> <p><code>LAST-ACK</code> 顾名思义等待最后的 ACK。是被动关闭的一方，发送 FIN 包给对端等待 ACK 确认时的状态。</p> <p>完整的模拟代码见：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_state/state_last_ack.pkt" target="_blank" rel="noopener noreferrer">state_last_ack.pkt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre><code>// 向协议栈注入 FIN 包，模拟客户端发送了 FIN，主动关闭连接
+.1 &lt; F. 1:1(0) win 65535  &lt;mss 100&gt; 
// 预期协议栈会发出 ACK
+0 &gt; . 1:1(0) ack 2 &lt;...&gt; 

+.1 close(4) = 0
// 预期服务端会发出 FIN
+0 &gt; F. 1:1(0) ack 2 &lt;...&gt; 


sudo netstat -lnpa  | grep 8080                                                                                                                                                                             1 ↵
tcp        0      0 192.168.190.26:8080     0.0.0.0:*               LISTEN      6163/packetdrill
tcp        1      1 192.168.190.26:8080     192.0.2.1:36054         LAST_ACK
</code></pre></div><p>当收到 ACK 以后，进入 <code>CLOSED</code> 状态，连接释放。</p> <h2 id="_11、closing"><a href="#_11、closing" class="header-anchor">#</a> 11、CLOSING</h2> <p><code>CLOSING</code>状态在「同时关闭」的情况下出现。这里的同时关闭中的「同时」其实并不是时间意义上的同时，而是指的是在发送 FIN 包还未收到确认之前，收到了对端的 FIN 的情况。</p> <p>我们用一个简单的脚本来模拟<code>CLOSING</code>状态。完整的代码见 <a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_connection_management/state-closing.pkt" target="_blank" rel="noopener noreferrer">state-closing.pkt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>​<br>
​<br>
+0.100 write(4, ..., 1000) = 1000</p> <div class="language- extra-class"><pre><code>+0 &gt; P. 1:1001(1000) ack 1 &lt;...&gt;
</code></pre></div><p>​<br>
+0.01 &lt; . 1:1(0) ack 1001 win 257</p> <p>​<br>
+.1 close(4) = 0</p> <div class="language- extra-class"><pre><code>+0 &gt; F. 1001:1001(0) ack 1 &lt;...&gt;
</code></pre></div><p>​<br>
+.1 &lt; F. 1:1(0) ack 1001 win 257</p> <p>​<br>
+0 &gt; . 1002:1002(0) ack 2 &lt;...&gt;</p> <p>​<br>
​<br>
​</p> <p>运行 packetdrill 执行上面的脚本，同时开启抓包。</p> <p>使用 netstat 查看当前的连接状态就可以看到 CLOSING 状态了。</p> <div class="language- extra-class"><pre><code>netstat -lnpa | grep -i 8080

tcp        0      0 192.168.60.204:8080     0.0.0.0:*               LISTEN      -
tcp        1      1 192.168.60.204:8080     192.0.2.1:55456         CLOSING     -
</code></pre></div><p>使用 wireshark 查看如下图所示，完整的抓包文件可以从 github 下载：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_connection_management/state-closing.pcap" target="_blank" rel="noopener noreferrer">state-closing.pcap<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/22/16b7c9fb03c6c24d" alt=""></p> <p>整个过程如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/22/16b7c9fb0e55ff72" alt=""></p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>到这里，TCP 的 11 种状态就介绍完了，我为了你准备了几道试题，看下自己的掌握的情况吧。</p> <h2 id="作业题"><a href="#作业题" class="header-anchor">#</a> 作业题</h2> <p>1、下列TCP连接建立过程描述正确的是：</p> <ul><li>A、服务端收到客户端的 SYN 包后等待 2*MSL 时间后就会进入 SYN_SENT 状态</li> <li>B、服务端收到客户端的 ACK 包后会进入 SYN_RCVD 状态</li> <li>C、当客户端处于 ESTABLISHED 状态时，服务端可能仍然处于 SYN_RCVD 状态</li> <li>D、服务端未收到客户端确认包，等待 2*MSL 时间后会直接关闭连接</li></ul> <p>2、TCP连接关闭，可能有经历哪几种状态：</p> <ul><li>A、LISTEN</li> <li>B、TIME-WAIT</li> <li>C、LAST-ACK</li> <li>D、SYN-RECEIVED</li></ul> <p><a href="https://juejin.im/book/6844733788681928712/section/6844733788828729357" target="_blank" rel="noopener noreferrer">Source<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book-docs/tcp-deep-analysis/12-时光机 —— TCP 头部时间戳选项.html" class="prev">
        12-时光机 —— TCP 头部时间戳选项.md
      </a></span> <span class="next"><a href="/book-docs/tcp-deep-analysis/14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.html">
        14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.md
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/book-docs/tcp-deep-analysis/assets/js/app.c5d1f0fa.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/11.4f919a5c.js" defer></script>
  </body>
</html>
