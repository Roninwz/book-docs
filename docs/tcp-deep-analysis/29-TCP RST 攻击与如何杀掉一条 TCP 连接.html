<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="技术文档">
    
    <link rel="preload" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.0ea9dfb1.css" as="style"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/app.411d3f03.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/28.3f365d4e.js" as="script"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/10.f0096057.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/11.afe0018d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/12.8691dd56.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/13.4570bab2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/14.6bb5eaad.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/15.d523fd97.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/16.be91c86f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/17.4f301f0a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/18.e0b82547.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/19.1c34c4fb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/20.5b297df0.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/21.1e4f6afa.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/22.1fd8c44a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/23.4806d06d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/24.64abf514.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/25.1db6ae87.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/26.79028ade.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/27.49378cc8.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/29.9e4d2797.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/3.874bed90.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/30.4e5f15e1.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/31.b0e97354.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/32.5ebf2421.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/33.75327db6.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/34.6fcf5c05.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/35.2076a0c2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/36.db825ac9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/37.3ce92f36.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/38.4afa2433.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/39.e7e9657a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/4.0892ecd3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/40.c62d5047.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/41.69a88bf2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/42.e6229e54.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/43.e36841dc.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/44.8e5155d3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/45.4c2a7d70.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/46.9ae4ac37.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/47.a075a79f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/5.864d5a79.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/6.19b45fc3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/7.2a1330f4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/8.8683fe45.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/9.c6213155.js">
    <link rel="stylesheet" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.0ea9dfb1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book-docs/tcp-deep-analysis/" class="home-link router-link-active"><!----> <span class="site-name">技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/book-docs/tcp-deep-analysis/1-开篇词 —— 小册食用指南.html" class="sidebar-link">1-开篇词 —— 小册食用指南.md</a></li><li><a href="/book-docs/tcp-deep-analysis/2-TCP_IP 历史与分层模型.html" class="sidebar-link">2-TCP_IP 历史与分层模型.md</a></li><li><a href="/book-docs/tcp-deep-analysis/3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.html" class="sidebar-link">3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.md</a></li><li><a href="/book-docs/tcp-deep-analysis/4-来自 Google 的协议栈测试神器 —— packetdrill.html" class="sidebar-link">4-来自 Google 的协议栈测试神器 —— packetdrill.md</a></li><li><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html" class="sidebar-link">5-支撑 TCP 协议的基石 —— 剖析首部字段.md</a></li><li><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html" class="sidebar-link">6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.md</a></li><li><a href="/book-docs/tcp-deep-analysis/7-繁忙的贸易港口 —— 聊聊端口号.html" class="sidebar-link">7-繁忙的贸易港口 —— 聊聊端口号.md</a></li><li><a href="/book-docs/tcp-deep-analysis/8-临时端口号是如何分配的.html" class="sidebar-link">8-临时端口号是如何分配的.md</a></li><li><a href="/book-docs/tcp-deep-analysis/9-TCP 恋爱史第一步 —— 从三次握手说起.html" class="sidebar-link">9-TCP 恋爱史第一步 —— 从三次握手说起.md</a></li><li><a href="/book-docs/tcp-deep-analysis/10-聊聊 TCP 自连接那些事.html" class="sidebar-link">10-聊聊 TCP 自连接那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/11-相见时难别亦难 —— 谈谈四次挥手.html" class="sidebar-link">11-相见时难别亦难 —— 谈谈四次挥手.md</a></li><li><a href="/book-docs/tcp-deep-analysis/12-时光机 —— TCP 头部时间戳选项.html" class="sidebar-link">12-时光机 —— TCP 头部时间戳选项.md</a></li><li><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html" class="sidebar-link">13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.md</a></li><li><a href="/book-docs/tcp-deep-analysis/14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.html" class="sidebar-link">14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.md</a></li><li><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html" class="sidebar-link">15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/16-嫌三次握手太慢 —— 来快速打开吧.html" class="sidebar-link">16-嫌三次握手太慢 —— 来快速打开吧.md</a></li><li><a href="/book-docs/tcp-deep-analysis/17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.html" class="sidebar-link">17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.md</a></li><li><a href="/book-docs/tcp-deep-analysis/18-一台主机上两个进程可以同时监听同一个端口吗.html" class="sidebar-link">18-一台主机上两个进程可以同时监听同一个端口吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/19-优雅关闭连接 —— Socket 选项之 SO_LINGER.html" class="sidebar-link">19-优雅关闭连接 —— Socket 选项之 SO_LINGER.md</a></li><li><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html" class="sidebar-link">20-一个神奇的状态 —— TIME_WAIT.md</a></li><li><a href="/book-docs/tcp-deep-analysis/21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.html" class="sidebar-link">21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.md</a></li><li><a href="/book-docs/tcp-deep-analysis/22-重传机制 —— 超时重传、快速重传与 SACK.html" class="sidebar-link">22-重传机制 —— 超时重传、快速重传与 SACK.md</a></li><li><a href="/book-docs/tcp-deep-analysis/23-重传间隔有讲究 —— 多久重传才合适.html" class="sidebar-link">23-重传间隔有讲究 —— 多久重传才合适.md</a></li><li><a href="/book-docs/tcp-deep-analysis/24-TCP流量控制 —— 滑动窗口.html" class="sidebar-link">24-TCP流量控制 —— 滑动窗口.md</a></li><li><a href="/book-docs/tcp-deep-analysis/25-有风度的 TCP —— 拥塞控制.html" class="sidebar-link">25-有风度的 TCP —— 拥塞控制.md</a></li><li><a href="/book-docs/tcp-deep-analysis/26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.html" class="sidebar-link">26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html" class="sidebar-link">27-TCP 回包的磨叽姐 —— 延迟确认那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/28-兄弟你还活着吗 —— keepalive 原理.html" class="sidebar-link">28-兄弟你还活着吗 —— keepalive 原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html" class="active sidebar-link">29-TCP RST 攻击与如何杀掉一条 TCP 连接.md</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html#rst-攻击" class="sidebar-link">RST 攻击</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html#工具一-tcpkill-工具使用及原理介绍" class="sidebar-link">工具一：tcpkill 工具使用及原理介绍</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html#killcx" class="sidebar-link">killcx</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html#小结" class="sidebar-link">小结</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html#扩展阅读" class="sidebar-link">扩展阅读</a></li></ul></li><li><a href="/book-docs/tcp-deep-analysis/30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.html" class="sidebar-link">30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.md</a></li><li><a href="/book-docs/tcp-deep-analysis/31-定时器一览 —— 细数 TCP 的定时器们.html" class="sidebar-link">31-定时器一览 —— 细数 TCP 的定时器们.md</a></li><li><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html" class="sidebar-link">32-网络工具篇（一） —— telnet、nc、netstat.md</a></li><li><a href="/book-docs/tcp-deep-analysis/33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.html" class="sidebar-link">33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.md</a></li><li><a href="/book-docs/tcp-deep-analysis/34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.html" class="sidebar-link">34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.md</a></li><li><a href="/book-docs/tcp-deep-analysis/35-案例分析 —— JDBC 批量插入真的就批量了吗.html" class="sidebar-link">35-案例分析 —— JDBC 批量插入真的就批量了吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/36-案例分析 —— TCP RST 包导致的网络血案.html" class="sidebar-link">36-案例分析 —— TCP RST 包导致的网络血案.md</a></li><li><a href="/book-docs/tcp-deep-analysis/37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.html" class="sidebar-link">37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.md</a></li><li><a href="/book-docs/tcp-deep-analysis/38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.html" class="sidebar-link">38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/39-作业题和思考题解析.html" class="sidebar-link">39-作业题和思考题解析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/40-网络学习一路困难，与君共勉.html" class="sidebar-link">40-网络学习一路困难，与君共勉.md</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>这篇文章我们来介绍 TCP RST 攻击以及如何在不干预通信双方进程的情况下杀掉一条 TCP 连接。</p> <h2 id="rst-攻击"><a href="#rst-攻击" class="header-anchor">#</a> RST 攻击</h2> <p>RST 攻击也称为伪造 TCP 重置报文攻击，通过伪造 RST 报文来关闭掉一个正常的连接。</p> <p>源 IP 地址伪造非常容易，不容易被伪造的是序列号，RST 攻击最重要的一点就是构造的包的序列号要落在对方的滑动窗口内，否则这个 RST 包会被忽略掉，达不到攻击的效果。</p> <p>下面我们用实验演示不在滑动窗口内的 RST 包会被忽略的情况，完整的代码见：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_rst/rst_out_of_window.pkt" target="_blank" rel="noopener noreferrer">rst_out_of_window.pkt<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre><code>+0 &lt; S 0:0(0) win 32792 &lt;mss 1460&gt; 
+0 &gt; S. 0:0(0) ack 1 &lt;...&gt;
+.1 &lt; . 1:1(0) ack 1 win 65535 
+0 accept(3, ..., ...) = 4
</code></pre></div><p>​<br>
+.010 &lt; R. 29202:29202(0) ack 1 win 65535</p> <p>​<br>
+.010 write(4, ..., 1000) = 1000</p> <p>​<br>
+0 &gt; P. 1:1001(1000) ack 1 &lt;...&gt;</p> <p>执行上面的脚本，抓包的结果如下，完整的包见：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_rst/rst_out_of_window.pcap" target="_blank" rel="noopener noreferrer">rst_out_of_window.pcap<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://store-g1.seewo.com/pics/201906221561214405280615612144052280.jpg" alt=""></p> <p>抓包文件中的第 5 个包可以看到，write 调用成功，1000 字节发送成功，write 调用并没有收到 RST 包的影响。</p> <p>下面来介绍两个工具，利用 RST 攻击的方式来杀掉一条连接。</p> <h2 id="工具一-tcpkill-工具使用及原理介绍"><a href="#工具一-tcpkill-工具使用及原理介绍" class="header-anchor">#</a> 工具一：tcpkill 工具使用及原理介绍</h2> <p>Centos 下安装 tcpkill 命令步骤如下</p> <div class="language- extra-class"><pre><code>yum install epel-release -y
yum install dsniff -y
</code></pre></div><p>实验步骤： 1、机器 c2(10.211.55.10) 启动 nc 命令监听 8080 端口，充当服务器端，记为 B</p> <div class="language- extra-class"><pre><code>nc -l 8080
</code></pre></div><p>2、机器 c2 启动 tcpdump 抓包</p> <div class="language- extra-class"><pre><code>sudo tcpdump -i any port 8080 -nn -U -vvv -w test.pcap
</code></pre></div><p>3、本地机器终端（10.211.55.2，记为 A）使用 nc 与 B 的 8080 端口建立 TCP 连接</p> <div class="language- extra-class"><pre><code>nc c2 8080
</code></pre></div><p>在服务端 B 机器上可以看到这条 TCP 连接</p> <div class="language- extra-class"><pre><code>netstat -nat | grep -i 8080
tcp        0      0 10.211.55.10:8080       10.211.55.2:60086       ESTABLISHED
</code></pre></div><p>4、启动 tcpkill</p> <div class="language- extra-class"><pre><code>sudo tcpkill -i eth0 port 8080
</code></pre></div><p>注意这个时候 tcp 连接依旧安然无恙，并没有被杀掉。</p> <p>5、在本地机器终端 nc 命令行中随便输入一点什么，这里输入<code>hello</code>，发现这时服务端和客户端的 nc 进程已经退出了</p> <p>下面来分析抓包文件，这个文件可以从我的 github 下载 <a href="https://github.com/arthur-zhang/tcp_ebook/tree/master/kill_tcp_connection" target="_blank" rel="noopener noreferrer">tcpkill.pcap<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/22/16b7eb9c7490b760" alt=""></p> <p>可以看到，tcpkill 假冒了 A 和 B 的 IP发送了 RST 包给通信的双方，那问题来了，伪造 ip 很简单，它是怎么知道当前会话的序列号的呢？</p> <p>tcpkill 的原理跟 tcpdump 差不多，会通过 libpcap 库抓取符合条件的包。 因此只有有数据传输的 tcp 连接它才可以拿到当前会话的序列号，通过这个序列号伪造 IP 发送符合条件的 RST 包。</p> <p>原理如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/22/16b7eb9c74a68a15" alt=""></p> <p>可以看到 tcpkill 对每个端发送了 3 个RST 包，这是因为在高速数据传输的连接上，根据当前抓的包计算的序列号可能已经不再 TCP 连接的窗口内了，这种情况下 RST 包会被忽略，因此默认情况下 tcpkill 未雨绸缪往后计算了几个序列号。还可以指定参数<code>-n</code>指定更多的 RST 包，比如<code>tcpkill -9</code></p> <p>根据上面的分析 tcpkill 的局限还是很明显的，无法杀掉一条僵死连接，下面我们介绍一个新的工具 killcx，看看它是如何来处理这种情况的。</p> <h2 id="killcx"><a href="#killcx" class="header-anchor">#</a> killcx</h2> <p>killcx 是一个用 perl 写的在 linux 下可以关闭 TCP 连接的脚本，无论 TCP 连接处于什么状态。</p> <p>下面来做一下实验，实验的前几步骤跟第一个例子中一模一样</p> <p>1、机器 c2(10.211.55.10) 启动 nc 命令监听 8080 端口，充当服务器端，记为 B</p> <div class="language- extra-class"><pre><code>nc -l 8080
</code></pre></div><p>2、机器 c2 启动 tcpdump 抓包</p> <div class="language- extra-class"><pre><code>sudo tcpdump -i any port 8080 -nn -U -vvv -w test.pcap
</code></pre></div><p>3、本地机器终端（10.211.55.2，记为 A）使用 nc 与 B 的 8080 端口建立 TCP 连接</p> <div class="language- extra-class"><pre><code>nc c2 8080
</code></pre></div><p>在服务端 B 机器上可以看到这条 TCP 连接</p> <div class="language- extra-class"><pre><code>netstat -nat | grep -i 8080
tcp        0      0 10.211.55.10:8080       10.211.55.2:61632       ESTABLISHED
</code></pre></div><p>4、客户端 A nc 命令行随便输入什么，这一步也完全可以省略，这里输入&quot;hello\n&quot;</p> <p>5、执行 killcx 命令，注意 killcx 是在步骤 4 之后执行的</p> <div class="language- extra-class"><pre><code>sudo ./killcx 10.211.55.2:61632
</code></pre></div><p>可以看到服务端和客户端的 nc 进程已经退出了。</p> <p>抓包的结果如下</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/22/16b7eb9cac8894d7" alt=""></p> <p>前 5 个包都很正常，三次握手加上一次数据传输，有趣的事情从第 6 个包开始</p> <ul><li>第 6 个包是 killcx 伪造 IP 向服务端 B 发送的一个 SYN 包</li> <li>第 7 个包是服务端 B 回复的 ACK 包，里面包含的 SEQ 和 ACK 号</li> <li>第 8 个包是 killcx 伪造 IP 向服务端 B 发送的 RST 包</li> <li>第 9 个包是 killcx 伪造 IP 向客户端 A 发送的 RST 包</li></ul> <p>整个过程如下图所示</p> <p><img src="https://user-gold-cdn.xitu.io/2019/6/22/16b7eb9c74a1f89a" alt=""></p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>这篇文章介绍了杀掉 TCP 连接的两个工具 tcpkill 和 killcx：</p> <ul><li>tcpkill 采用了比较保守的方式，抓取流量等有新包到来的时候，获取 SEQ/ACK 号，这种方式只能杀掉有数据传输的连接</li> <li>killcx 采用了更加主动的方式，主动发送 SYN 包获取 SEQ/ACK 号，这种方式活跃和非活跃的连接都可以杀掉</li></ul> <h2 id="扩展阅读"><a href="#扩展阅读" class="header-anchor">#</a> 扩展阅读</h2> <p>有大神把 tcpkill 源代码魔改了一下，让 tcpkill 也支持了杀掉非活跃连接，原理上就是结合了 killcx 杀掉连接的方式，模拟 SYN 包。有兴趣的读者可以好好读一下：<a href="https://yq.aliyun.com/articles/59308" target="_blank" rel="noopener noreferrer">yq.aliyun.com/articles/59…<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.im/book/6844733788681928712/section/6844733788845522951" target="_blank" rel="noopener noreferrer">Source<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book-docs/tcp-deep-analysis/28-兄弟你还活着吗 —— keepalive 原理.html" class="prev">
        28-兄弟你还活着吗 —— keepalive 原理.md
      </a></span> <span class="next"><a href="/book-docs/tcp-deep-analysis/30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.html">
        30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.md
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/book-docs/tcp-deep-analysis/assets/js/app.411d3f03.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/28.3f365d4e.js" defer></script>
  </body>
</html>
