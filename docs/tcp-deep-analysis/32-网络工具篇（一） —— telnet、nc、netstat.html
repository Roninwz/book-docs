<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="技术文档">
    
    <link rel="preload" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.1ae38039.css" as="style"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/app.c5d1f0fa.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/32.05263bfb.js" as="script"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/10.456c114f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/11.4f919a5c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/12.8691dd56.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/13.6eb06c9f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/14.8ea58ce4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/15.99b76ce3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/16.892ccdbb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/17.46486d87.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/18.1ae83189.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/19.6788fb0a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/20.38eb4e81.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/21.dd2d7e3c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/22.1fd8c44a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/23.7a6fd38e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/24.4006c26f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/25.acd18f3e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/26.d393a91d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/27.5eb2dc92.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/28.2f7d9a61.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/29.1b6a2c80.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/3.086afb7c.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/30.7b2345d3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/31.eec26697.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/33.0a453fe1.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/34.6fcf5c05.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/35.2076a0c2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/36.db825ac9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/37.3ce92f36.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/38.419ced31.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/39.e7e9657a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/4.1e02d683.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/40.11cc02bb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/41.e5c285f2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/42.d1465cb7.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/43.bba7aad7.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/44.c74f481b.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/45.4c2a7d70.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/46.917e2cae.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/47.5ae9bff9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/5.ed3e8199.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/6.19b45fc3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/7.2a1330f4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/8.8683fe45.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/9.b4387ffc.js">
    <link rel="stylesheet" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.1ae38039.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book-docs/tcp-deep-analysis/" class="home-link router-link-active"><!----> <span class="site-name">技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/book-docs/tcp-deep-analysis/1-开篇词 —— 小册食用指南.html" class="sidebar-link">1-开篇词 —— 小册食用指南.md</a></li><li><a href="/book-docs/tcp-deep-analysis/10-聊聊 TCP 自连接那些事.html" class="sidebar-link">10-聊聊 TCP 自连接那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/11-相见时难别亦难 —— 谈谈四次挥手.html" class="sidebar-link">11-相见时难别亦难 —— 谈谈四次挥手.md</a></li><li><a href="/book-docs/tcp-deep-analysis/12-时光机 —— TCP 头部时间戳选项.html" class="sidebar-link">12-时光机 —— TCP 头部时间戳选项.md</a></li><li><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html" class="sidebar-link">13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.md</a></li><li><a href="/book-docs/tcp-deep-analysis/14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.html" class="sidebar-link">14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.md</a></li><li><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html" class="sidebar-link">15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/16-嫌三次握手太慢 —— 来快速打开吧.html" class="sidebar-link">16-嫌三次握手太慢 —— 来快速打开吧.md</a></li><li><a href="/book-docs/tcp-deep-analysis/17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.html" class="sidebar-link">17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.md</a></li><li><a href="/book-docs/tcp-deep-analysis/18-一台主机上两个进程可以同时监听同一个端口吗.html" class="sidebar-link">18-一台主机上两个进程可以同时监听同一个端口吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/19-优雅关闭连接 —— Socket 选项之 SO_LINGER.html" class="sidebar-link">19-优雅关闭连接 —— Socket 选项之 SO_LINGER.md</a></li><li><a href="/book-docs/tcp-deep-analysis/2-TCP_IP 历史与分层模型.html" class="sidebar-link">2-TCP_IP 历史与分层模型.md</a></li><li><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html" class="sidebar-link">20-一个神奇的状态 —— TIME_WAIT.md</a></li><li><a href="/book-docs/tcp-deep-analysis/21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.html" class="sidebar-link">21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.md</a></li><li><a href="/book-docs/tcp-deep-analysis/22-重传机制 —— 超时重传、快速重传与 SACK.html" class="sidebar-link">22-重传机制 —— 超时重传、快速重传与 SACK.md</a></li><li><a href="/book-docs/tcp-deep-analysis/23-重传间隔有讲究 —— 多久重传才合适.html" class="sidebar-link">23-重传间隔有讲究 —— 多久重传才合适.md</a></li><li><a href="/book-docs/tcp-deep-analysis/24-TCP流量控制 —— 滑动窗口.html" class="sidebar-link">24-TCP流量控制 —— 滑动窗口.md</a></li><li><a href="/book-docs/tcp-deep-analysis/25-有风度的 TCP —— 拥塞控制.html" class="sidebar-link">25-有风度的 TCP —— 拥塞控制.md</a></li><li><a href="/book-docs/tcp-deep-analysis/26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.html" class="sidebar-link">26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html" class="sidebar-link">27-TCP 回包的磨叽姐 —— 延迟确认那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/28-兄弟你还活着吗 —— keepalive 原理.html" class="sidebar-link">28-兄弟你还活着吗 —— keepalive 原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html" class="sidebar-link">29-TCP RST 攻击与如何杀掉一条 TCP 连接.md</a></li><li><a href="/book-docs/tcp-deep-analysis/3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.html" class="sidebar-link">3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.md</a></li><li><a href="/book-docs/tcp-deep-analysis/30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.html" class="sidebar-link">30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.md</a></li><li><a href="/book-docs/tcp-deep-analysis/31-定时器一览 —— 细数 TCP 的定时器们.html" class="sidebar-link">31-定时器一览 —— 细数 TCP 的定时器们.md</a></li><li><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html" class="active sidebar-link">32-网络工具篇（一） —— telnet、nc、netstat.md</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html#命令一-telnet" class="sidebar-link">命令一：telnet</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html#命令二-netcat" class="sidebar-link">命令二：netcat</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html#命令三-netstat" class="sidebar-link">命令三：netstat</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html#小结与思考题" class="sidebar-link">小结与思考题</a></li></ul></li><li><a href="/book-docs/tcp-deep-analysis/33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.html" class="sidebar-link">33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.md</a></li><li><a href="/book-docs/tcp-deep-analysis/34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.html" class="sidebar-link">34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.md</a></li><li><a href="/book-docs/tcp-deep-analysis/35-案例分析 —— JDBC 批量插入真的就批量了吗.html" class="sidebar-link">35-案例分析 —— JDBC 批量插入真的就批量了吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/36-案例分析 —— TCP RST 包导致的网络血案.html" class="sidebar-link">36-案例分析 —— TCP RST 包导致的网络血案.md</a></li><li><a href="/book-docs/tcp-deep-analysis/37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.html" class="sidebar-link">37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.md</a></li><li><a href="/book-docs/tcp-deep-analysis/38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.html" class="sidebar-link">38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/39-作业题和思考题解析.html" class="sidebar-link">39-作业题和思考题解析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/4-来自 Google 的协议栈测试神器 —— packetdrill.html" class="sidebar-link">4-来自 Google 的协议栈测试神器 —— packetdrill.md</a></li><li><a href="/book-docs/tcp-deep-analysis/40-网络学习一路困难，与君共勉.html" class="sidebar-link">40-网络学习一路困难，与君共勉.md</a></li><li><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html" class="sidebar-link">5-支撑 TCP 协议的基石 —— 剖析首部字段.md</a></li><li><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html" class="sidebar-link">6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.md</a></li><li><a href="/book-docs/tcp-deep-analysis/7-繁忙的贸易港口 —— 聊聊端口号.html" class="sidebar-link">7-繁忙的贸易港口 —— 聊聊端口号.md</a></li><li><a href="/book-docs/tcp-deep-analysis/8-临时端口号是如何分配的.html" class="sidebar-link">8-临时端口号是如何分配的.md</a></li><li><a href="/book-docs/tcp-deep-analysis/9-TCP 恋爱史第一步 —— 从三次握手说起.html" class="sidebar-link">9-TCP 恋爱史第一步 —— 从三次握手说起.md</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>今天我们来介绍三个常用的命令：telnet、nc 和 netstat</p> <h2 id="命令一-telnet"><a href="#命令一-telnet" class="header-anchor">#</a> 命令一：telnet</h2> <p>现在 telnet server 几乎没有人在用了，但是 telnet client 却被广泛的使用着。它的功能已经比较强大，有较多巧妙的用法。下面选取几个用的比较多的来介绍一下。</p> <h3 id="_0x01-检查端口是否打开"><a href="#_0x01-检查端口是否打开" class="header-anchor">#</a> 0x01 检查端口是否打开</h3> <p>telnet 的一个最大作用就是检查一个端口是否处于打开，使用的命令是 <code>telnet [domainname or ip] [port]</code>，这条命令能告诉我们到远端 server 指定端口的网连接是否可达。</p> <blockquote><p>telnet [domainname or ip] [port]</p></blockquote> <p>telnet 第一个参数是要连接的域名或者 ip，第二个参数是要连接的端口。</p> <p>比如你要连接 220.181.57.216（百度) 服务器上的 80 端口，可以使用如下的命令：<code>telnet 220.181.57.216 80</code></p> <p>如果这个网络连接可达，则会提示你<code>Connected to 220.181.57.216</code>，输入<code>control ]</code>可以给这个端口发送数据包了</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b04184c7883850" alt="-w349"></p> <p>如果网路不可达，则会提示<code>telnet: Unable to connect to remote host</code>和具体不能连上的原因，常见的有 Operation timed out、Connection refused。</p> <p>比如我本机没有进程监听 90 端口，<code>telnet 127.0.0.1 90</code>的信息如下</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b04184cf017730" alt="-w549"></p> <h3 id="_0x02-telnet-还能发-http-请求"><a href="#_0x02-telnet-还能发-http-请求" class="header-anchor">#</a> 0x02 telnet 还能发 http 请求？</h3> <p>我们知道 curl 可以方便的发送 http 请求，telnet 也是可以方便的发送 http 请求的</p> <p>执行 <code>telnet www.baidu.com 80</code>，粘贴下面的文本（注意总共有四行，最后两行为两个空行）</p> <div class="language- extra-class"><pre><code>GET / HTTP/1.1
Host: www.baidu.com
</code></pre></div><p>​<br>
​</p> <p>可以看到返回了百度的首页</p> <div class="language- extra-class"><pre><code>➜ telnet www.baidu.com 80
Trying 14.215.177.38...
Connected to www.a.shifen.com.
Escape character is '^]'.
GET / HTTP/1.1
Host: www.baidu.com

HTTP/1.1 200 OK
Accept-Ranges: bytes
Cache-Control: no-cache
Connection: Keep-Alive
Content-Length: 14615
...
</code></pre></div><h3 id="_0x03-telnet-还可以连接-redis"><a href="#_0x03-telnet-还可以连接-redis" class="header-anchor">#</a> 0x03 telnet 还可以连接 Redis</h3> <p>假设 redis 服务器跑在本地，监听 6379端口，用 <code>telnet 6379</code> 命令可以连接上。接下来就可以调用 redis 的命令。</p> <p>调用&quot;set hello world&quot;，给 key 为 hello 设置值为 &quot;world&quot;，随后调用 get hello 获取值</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b04184ccd3d71d?imageslim" alt="render1548074308853"></p> <p>Redis 客户端和 Redis 服务器使用 RESP 协议通信，RESP 是 REdis Serialization Protocol 的简称。在 RESP 中，通过检查服务器返回数据的第一个字节来确定这个回复是什么类型：</p> <ul><li>对于 Simple Strings 来说，第一个字节是 &quot;+&quot;</li> <li>对于 Errors 来说，第一个字节是 &quot;-&quot;</li> <li>对于 Integers 来说，第一个字节是 &quot;:&quot;</li> <li>对于 Bulk Strings 来说，首字节是 &quot;$&quot;</li> <li>对于 Arrays 来说，首字节是 &quot;*&quot;</li></ul> <blockquote><p>RESP Simple Strings</p></blockquote> <p>Simple Strings 被用来传输非二进制安全的字符串，是按下面的方式进行编码: 一个加号，紧接着是不包含 CR 或者 LF 的字符串(不允许换行)，最后以CRLF(&quot;\r\n&quot;)结尾。</p> <p>执行 &quot;set hello world&quot; 命令成功，服务器会响应一个 &quot;OK&quot;，这是 RESP 一种 Simple Strings 的场景，这种情况下，OK 被编码为五个字节：<code>+OK\r\n</code></p> <blockquote><p>RESP Bulk Strings</p></blockquote> <p>get 命令读取 hello 的值，redis 服务器返回 <code>$5\r\nworld\r\n</code>，这种类型属于是 Bulk Strings 被用来表示二进制安全的字符串。</p> <p>Bulk Strings 的编码方式是下面这种方式：以 &quot;$&quot; 开头，后跟实际要发送的字节数，随后是 CRLF，然后是实际的字符串数据，最后以 CRLF 结束。</p> <p>所以 &quot;world&quot; 这个 string 会被编码成这样：<code>$5\r\nworld\r\n</code></p> <h2 id="命令二-netcat"><a href="#命令二-netcat" class="header-anchor">#</a> 命令二：netcat</h2> <p>netcat 因为功能强大，被称为网络工具中的瑞士军刀，nc 是 netcat 的简称。这篇文章将介绍 nc 常用的几个场景。</p> <h3 id="_0x01-用-nc-来当聊天服务器"><a href="#_0x01-用-nc-来当聊天服务器" class="header-anchor">#</a> 0x01 用 nc 来当聊天服务器</h3> <p>实验步骤</p> <ol><li><p>在服务器（10.211.55.5）命令行输入 <code>nc -l 9090</code></p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/7/169580bcb1c2c573" alt=""></p> <p>这里的 <code>-l</code> 参数表示 nc 将监听某个端口，<code>l</code>的含义是 listen。后面紧跟的 9090 表示要监听的端口号为 9090。</p></li> <li><p>在另外客户端机器的终端中输入<code>nc 10.211.55.5 9090</code></p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/7/169580bcb1d7091c" alt=""></p> <p>此时两台机器建立了一条 tcp 连接</p></li> <li><p>在客户端终端中输入 &quot;Hello, this is a message from client&quot;</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/7/169580bcb2645f30" alt=""></p> <p>可以看到服务器终端显示出了客户端输入的消息</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/7/169580bcb306b7c8" alt=""></p></li> <li><p>在服务器终端输入 &quot;Hello, this is a message from server&quot;</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/7/169580bcb3f8e380" alt=""></p> <p>可以看到客户端终端显示了刚刚服务器端输入的消息</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/7/169580bcb44ec564" alt=""></p></li></ol> <p>如果不想继续聊下去，在任意一端输入&quot;Ctrl c&quot;都会终止这个连接。</p> <p>当然，真正在现实场景中用 nc 来聊天用的非常少。<code>nc -l</code>命令一个有价值的地方是可以快速的启动一个 tcp server 监听某个端口。</p> <h3 id="_0x02-发送-http-请求"><a href="#_0x02-发送-http-请求" class="header-anchor">#</a> 0x02 发送 http 请求</h3> <p>先访问一次 www.baidu.com 拿到百度服务器的 ip（183.232.231.172）</p> <p>输入 &quot;nc 183.232.231.172 80&quot;，然后输入enter，</p> <div class="language- extra-class"><pre><code>nc 183.232.231.172 80
&lt;enter&gt;
&lt;enter&gt;
</code></pre></div><p>百度的服务器返回了一个 http 的报文 <code>HTTP/1.1 400 Bad Request</code></p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/7/169580bcea03aa7e" alt=""></p> <p>来回忆一下 HTTP 请求报文的组成：</p> <ol><li><p>起始行（start line）</p></li> <li><p>首部（header）</p></li> <li><p>可选的内容主体（body）</p> <p>nc 183.232.231.172 80
GET / HTTP/1.1
host: www.baidu.com
<enter><enter></enter></enter></p></li></ol> <p><img src="https://user-gold-cdn.xitu.io/2019/3/7/169580be833e11cc" alt=""></p> <p>除了狂按 enter，你也可以采用 unix 管道的方式，把 HTTP 请求报文传输过去</p> <div class="language- extra-class"><pre><code>echo -ne &quot;GET / HTTP/1.1\r\nhost:www.baidu.com\r\n\r\n&quot; | nc 183.232.231.172 80
</code></pre></div><p>echo 的 -n 参数很关键，echo 默认会在输出的最后增加一个换行，加上 -n 参数以后就不会在最后自动换行了。</p> <p>执行上面的命令，可以看到也返回了百度的首页 html</p> <h3 id="_0x03-查看远程端口是否打开"><a href="#_0x03-查看远程端口是否打开" class="header-anchor">#</a> 0x03 查看远程端口是否打开</h3> <p>前面介绍过 telnet 命令也可以检查远程端口是否打开，既然 nc 被称为瑞士军刀，这个小功能不能说不行。</p> <blockquote><p>nc -zv [host or ip] [port]</p></blockquote> <p>其中 -z 参数表示不发送任何数据包，tcp 三次握手完后自动退出进程。有了 -v 参数则会输出更多详细信息（verbose）。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/7/169580bd23a6dcae" alt=""></p> <h3 id="_0x04-访问-redis"><a href="#_0x04-访问-redis" class="header-anchor">#</a> 0x04 访问 redis</h3> <p>nc 为 在没有 redis-cli 的情况下访问 redis 又新增了一种方法</p> <div class="language- extra-class"><pre><code>nc localhost 6379
ping
+PONG
get hello
$5
world
</code></pre></div><p>同样可以把命令通过管道的方式传给 redis 服务器。</p> <div class="language- extra-class"><pre><code>echo ping  | nc localhost 6379
+PONG
</code></pre></div><h2 id="命令三-netstat"><a href="#命令三-netstat" class="header-anchor">#</a> 命令三：netstat</h2> <p>netstat 很强大的网络工具，可以用来显示套接字的状态。下面来介绍一下常用的命令选项</p> <h3 id="列出所有套接字"><a href="#列出所有套接字" class="header-anchor">#</a> 列出所有套接字</h3> <div class="language- extra-class"><pre><code>netstat -a
</code></pre></div><p><code>-a</code>命令可以输出所有的套接字，包括监听的和未监听的套接字。 示例输出：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b04184cf1da045" alt=""></p> <h3 id="只列出-tcp-套接字"><a href="#只列出-tcp-套接字" class="header-anchor">#</a> 只列出 TCP 套接字</h3> <div class="language- extra-class"><pre><code>netstat -at
</code></pre></div><p><code>-t</code> 选项可以只列出 TCP 的套接字，也可也用<code>--tcp</code></p> <p>示例输出</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b04184cf2ce909" alt=""></p> <h3 id="只列出-udp-连接"><a href="#只列出-udp-连接" class="header-anchor">#</a> 只列出 UDP 连接</h3> <div class="language- extra-class"><pre><code>netstat -au
</code></pre></div><p><code>-u</code> 选项用来指定显示 UDP 的连接，也可也用<code>--udp</code> 示例输出：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b04184d021165b" alt=""></p> <h3 id="只列出处于监听状态的连接"><a href="#只列出处于监听状态的连接" class="header-anchor">#</a> 只列出处于监听状态的连接</h3> <div class="language- extra-class"><pre><code>netstat -l
</code></pre></div><p><code>-l</code> 选项用来指定处于 LISTEN 状态的连接，也可以用<code>--listening</code> 示例输出：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b0418533dc022b" alt=""></p> <p>与<code>-a</code>一样，可以组合<code>-t</code>来过滤处于 listen 状态的 TCP 连接</p> <div class="language- extra-class"><pre><code>netstat -lt
</code></pre></div><p>示例输出</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b0418538632d79" alt=""></p> <h3 id="禁用端口-和-ip-映射"><a href="#禁用端口-和-ip-映射" class="header-anchor">#</a> 禁用端口 和 IP 映射</h3> <div class="language- extra-class"><pre><code>netstat -ltn
</code></pre></div><p>上面的例子中，常用端口都被映射为了名字，比如 22 端口输出显示为 ssh，8080 端口被映射为 webcache。大部分情况下，我们并不想 netstat 帮我们做这样的事情，可以加上<code>-n</code>禁用</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b04185f51f091f" alt=""></p> <h3 id="显示进程"><a href="#显示进程" class="header-anchor">#</a> 显示进程</h3> <div class="language- extra-class"><pre><code>netstat -ltnp
</code></pre></div><p>使用 <code>-p</code>命令可以显示连接归属的进程信息，在查看端口被哪个进程占用时非常有用 示例输出如下：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b04185b89d751d" alt=""></p> <h3 id="显示所有的网卡信息"><a href="#显示所有的网卡信息" class="header-anchor">#</a> 显示所有的网卡信息</h3> <div class="language- extra-class"><pre><code>netstat -i
</code></pre></div><p>用 <code>-i</code> 命令可以列出网卡信息，比如 MTU 等</p> <p>示例输出</p> <p><img src="https://user-gold-cdn.xitu.io/2019/5/29/16b041861f153178" alt=""></p> <p>到此，netstat 基本命令选项都介绍完了，可以管道操作进行进一步的过滤。</p> <h3 id="显示-8080-端口所有处于-established-状态的连接"><a href="#显示-8080-端口所有处于-established-状态的连接" class="header-anchor">#</a> 显示 8080 端口所有处于 ESTABLISHED 状态的连接</h3> <div class="language- extra-class"><pre><code>netstat -atnp | grep &quot;:8080&quot; | grep ESTABLISHED
tcp        0      0 10.211.55.10:8080       10.211.55.5:45438       ESTABLISHED 24972/nc
</code></pre></div><h3 id="统计处于各个状态的连接个数"><a href="#统计处于各个状态的连接个数" class="header-anchor">#</a> 统计处于各个状态的连接个数</h3> <div class="language- extra-class"><pre><code>netstat -ant | awk '{print $6}' | sort | uniq -c | sort -n
      1 established)
      1 Foreign
      2 LISTEN
      3 TIME_WAIT
     30 ESTABLISHED
</code></pre></div><p>使用 awk 截取出状态行，然后用 sort、uniq 进行去重和计数即可</p> <h2 id="小结与思考题"><a href="#小结与思考题" class="header-anchor">#</a> 小结与思考题</h2> <p>这篇文章我们首先讲解了 telnet 的妙用，来回顾一下重点：第一， telnet 可以检查指定端口是否存在，用来判断指定的网络连接是否可达。第二 telnet 可以用来发送 HTTP 请求，HTTP 是基于 TCP 的应用层协议，可以认为 telnet 是 TCP 包的一个构造工具，只要构造出的包符合 HTTP 协议的格式，就可以得到正确的返回。第三，介绍了如何用 telnet 访问 redis 服务器，在没有安装 redis-cli 的情况下，也可以通过 telnet 的方式来快速进行访问，然后结合实际场景介绍了 Redis 的通信协议 RESP。</p> <p>然后介绍了 nc 在诸多类似场景下的应用，最后介绍了 netstat 命令的的用法。</p> <p>留一道作业题：</p> <ul><li>怎么样用 nc 发送 UDP 数据</li></ul> <p>欢迎你在留言区留言，和我一起讨论。</p> <p><a href="https://juejin.im/book/6844733788681928712/section/6844733788849700878" target="_blank" rel="noopener noreferrer">Source<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book-docs/tcp-deep-analysis/31-定时器一览 —— 细数 TCP 的定时器们.html" class="prev">
        31-定时器一览 —— 细数 TCP 的定时器们.md
      </a></span> <span class="next"><a href="/book-docs/tcp-deep-analysis/33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.html">
        33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.md
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/book-docs/tcp-deep-analysis/assets/js/app.c5d1f0fa.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/32.05263bfb.js" defer></script>
  </body>
</html>
