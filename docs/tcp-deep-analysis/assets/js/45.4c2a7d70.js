(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{430:function(n,t,e){"use strict";e.r(t);var s=e(54),a=Object(s.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("我们知道客户端主动发起请求 connect 时，操作系统会为它分配一个临时端口（ephemeral port）。在 linux 上 这个端口的取值范围由 "),e("code",[n._v("/proc/sys/net/ipv4/ip_local_port_range")]),n._v(" 文件的值决定，在我的 CentOS 机器上，临时端口的范围是 32768~60999。")]),n._v(" "),e("p",[n._v("有两种典型的使用方式会生成临时端口：")]),n._v(" "),e("ul",[e("li",[n._v("调用 bind 函数不指定端口")]),n._v(" "),e("li",[n._v("调用 connect 函数")])]),n._v(" "),e("p",[n._v("先来看 bind 调用的例子，故意注释掉端口的赋值，完整的代码如下。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("int main(void) {\n  int listenfd;\n  socklen_t clilen;\n  struct sockaddr_in cliaddr, servaddr;\n  listenfd = socket(AF_INET, SOCK_STREAM, 0);\n  bzero(&servaddr, sizeof(servaddr));\n  servaddr.sin_family = AF_INET;\n  servaddr.sin_addr.s_addr = htonl (INADDR_ANY);\n  // 这里故意注释掉端口的赋值\n  //  servaddr.sin_port = htons (9090);\n  bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr));\n  listen(listenfd, 5);\n  clilen = sizeof(cliaddr);\n  accept(listenfd, (struct sockaddr *)&cliaddr, &clilen);\n  sleep(-1);\n  return 1;\n}\n")])])]),e("p",[n._v("编译执行上面的代码，使用 netstat 可以看到 linux 自动为其分配了一个临时的端口 40843。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 0.0.0.0:40843           0.0.0.0:*               LISTEN      21608/./a.out\n")])])]),e("p",[n._v("再来看第二个例子客户端 connect，使用 nc 或者 telnet 访问本地或远程的服务时，都会自动分配一个临时端口号。比如执行 "),e("code",[n._v("nc localhost 8080")]),n._v(" 访问本机的 web 服务器，随后使用 netstat 查看连接状态，可以看到分配了临时端口号 37778。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 127.0.0.1:37778         127.0.0.1:8080          ESTABLISHED 22126/nc\n")])])]),e("h2",{attrs:{id:"临时端口号分配的源码分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#临时端口号分配的源码分析"}},[n._v("#")]),n._v(" 临时端口号分配的源码分析")]),n._v(" "),e("p",[n._v("接下来的内容以 connect 为例，linux 内核版本是 3.10.0。核心的代码在 net/ipv4/inet_hashtables.c 中，为了方便我做了部分精简。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("int __inet_hash_connect(struct sock *sk, u32 port_offset) {\n  int low;  // 临时端口号的下界\n  int high; // 临时端口号的上界\n  static u32 hint; // 使用静态变量保存的递增值，减少 offset 冲突的可能性\n  // port_offset 是根据源地址、目的地址、目标端口计算出的哈希值\n  u32 offset = hint + port_offset;\n  int port;\n\n  // 读取 /proc/sys/net/ipv4/ip_local_port_range 的临时端号的上界和下界\n  inet_get_local_port_range(net, &low, &high);\n\n  // remaining 是临时端口号可分配值的范围\n  int remaining = (high - low) + 1;\n\n  /* By starting with offset being an even number,\n   * we tend to leave about 50% of ports for other uses,\n   * like bind(0).\n   */\n  offset &= ~1; // 将最后一位置为 0\n\n  int i;\n  // 从 0 开始遍历，查找未被占用的端口号\n  for (i = 0; i < remaining; i++) {\n    // 保证 port 的范围是在 low~high 之间\n    port = low + (i + offset) % remaining;\n    // 检查端口号是否属于保留端口号\n    if (inet_is_reserved_local_port(port))\n      continue;\n    // 接下来检查端口是否被占用、等逻辑\n    if (all_ok) {\n      goto ok;\n    }\n\n  }\n  ok:\n      // 下次 connect 时 hint 递增，减少端口号冲突的概率\n      hint += (i + 2) & ~1;\n}\n")])])]),e("p",[n._v("其中传入的 port_offset 的计算逻辑是在 net/core/secure_seq.c 的 secure_ipv4_port_ephemeral 方法中实现的，代码如下。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\n\tnet_secret_init();\n\thash[0] = (__force u32)saddr; // 源地址\n\thash[1] = (__force u32)daddr; // 目标地址\n\thash[2] = (__force u32)dport ^ net_secret[14]; // 目标端口号\n\thash[3] = net_secret[15];\n\n\tmd5_transform(hash, net_secret); // 计算 MD5值\n\n\treturn hash[0];\n}\n")])])]),e("p",[n._v("因为此时还没有源端口，这个函数使用源地址、目标地址、目标端口号这三个元素进行 MD5 运算得到一个 offset 值，通过同一组源地址、目标地址、目标端口号计算出的 offset 值相等，这也是为什么需要加入地址 hint 的原因，否则使对同一个目标端口服务同时进行请求时，第一次 for 循环计算出来的端口都是一样的。加入了递增的 hint 以后，就可以避免这种情况了。")]),n._v(" "),e("h2",{attrs:{id:"内核调试"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内核调试"}},[n._v("#")]),n._v(" 内核调试")]),n._v(" "),e("p",[n._v("以一次实际的计算为例，经过调试 linux 内核，在某一次 "),e("code",[n._v("telnet localhost 2000")]),n._v(" 过程中，分配到的临时端口号是 48968，如下所示。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 127.0.0.1:48968         127.0.0.1:2000          ESTABLISHED 16475/telnet\n")])])]),e("p",[n._v("下面看下计算的过程。")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("根据 ip_local_port_range 的值，low=32768，high=48948，remaining=28232")])]),n._v(" "),e("li",[e("p",[n._v("在我的虚拟机中，除了测试的代码没有跑其它的应用，分配端口号不会冲突，面代码中的 for 循环只会循环一次，i 值等于 0。")])]),n._v(" "),e("li",[e("p",[n._v("在此次测试中 hint=32，port_offset=266836801")]),n._v(" "),e("p",[n._v("// offset = 32 + 266836801 = 0xfe79b61\nu32 offset = hint + port_offset;")]),n._v(" "),e("p",[n._v("// offset = 0xfe79b60\noffset &= ~1; // 将最后一位置为 0\n// port = 32768 + (0 + 0xfe79b60) % 28232\n// port = 32768 + 16200 = 48968\nport = low + (i + offset) % remaining;")])])]),n._v(" "),e("h2",{attrs:{id:"临时端口号分配完了会发生什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#临时端口号分配完了会发生什么"}},[n._v("#")]),n._v(" 临时端口号分配完了会发生什么")]),n._v(" "),e("p",[n._v("如果短时间内大量 connect，耗尽了所有临时端口号会发生什么？我们来实测一下。")]),n._v(" "),e("p",[n._v("使用 sysctl 修改 ip_local_port_range 的范围，只允许分配一个端口 50001，如下所示。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('sudo sysctl -w net.ipv4.ip_local_port_range="50001 50001"\n')])])]),e("p",[n._v("使用 nc 或者 telnet 等工具发起 TCP 连接，这里使用"),e("code",[n._v("nc -4 localhost 22")]),n._v("，使用 netstat 查看当前连接信息，可以看到分配的临时端口为 50001，如下所示。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 127.0.0.1:50001         127.0.0.1:22            ESTABLISHED 18605/nc\n")])])]),e("p",[n._v("再次执行 nc 发起连接，可以看到这次失败了，如下所示。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("nc -4 localhost 22\n                                                                                                                                             \nNcat: Cannot assign requested address.\n")])])]),e("p",[n._v("使用 strace 查看 nc 命令系统调用。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("strace nc -4 localhost 22\n")])])]),e("p",[n._v("系统调用如下所示。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3\nfcntl(3, F_GETFL)                       = 0x2 (flags O_RDWR)\nfcntl(3, F_SETFL, O_RDWR|O_NONBLOCK)    = 0\nconnect(3, {sa_family=AF_INET, sin_port=htons(22), sin_addr=inet_addr("127.0.0.1")}, 16) = -1 EADDRNOTAVAIL (Cannot assign requested address)\n...\n')])])]),e("p",[n._v("可以看到 connect 调用返回了 EADDRNOTAVAIL 错误。使用 golang 的代码和结果如下所示。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('package main\n\nimport (\n\t"fmt"\n\t"net"\n\t"time"\n)\n\nfunc main() {\n\t// 仅使用 ipv4\n\t_, err := net.Dial("tcp4", "localhost:22")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\ttime.Sleep(time.Minute * 10)\n}\n')])])]),e("p",[n._v("编译运行上面的 go 代码结果如下所示。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("dial tcp4 127.0.0.1:22: connect: cannot assign requested address\n")])])]),e("p",[e("a",{attrs:{href:"https://juejin.im/book/6844733788681928712/section/6844733788820340744",target:"_blank",rel:"noopener noreferrer"}},[n._v("Source"),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);