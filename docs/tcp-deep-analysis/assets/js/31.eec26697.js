(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{414:function(t,_,s){"use strict";s.r(_);var e=s(54),v=Object(e.a)({},(function(){var t=this,_=t.$createElement,s=t._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("TCP 为每条连接建立了 7 个定时器：")]),t._v(" "),s("ul",[s("li",[t._v("连接建立定时器")]),t._v(" "),s("li",[t._v("重传定时器")]),t._v(" "),s("li",[t._v("延迟 ACK 定时器")]),t._v(" "),s("li",[t._v("PERSIST 定时器")]),t._v(" "),s("li",[t._v("KEEPALIVE 定时器")]),t._v(" "),s("li",[t._v("FIN_WAIT_2 定时器")]),t._v(" "),s("li",[t._v("TIME_WAIT 定时器")])]),t._v(" "),s("p",[t._v("大部分定时器在前面的文章已经介绍过了，这篇文章来总结一下。")]),t._v(" "),s("h2",{attrs:{id:"_0x01-连接建立定时器-connection-establishment"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x01-连接建立定时器-connection-establishment"}},[t._v("#")]),t._v(" 0x01 连接建立定时器（connection establishment）")]),t._v(" "),s("p",[t._v("当发送端发送 SYN 报文想建立一条新连接时，会开启连接建立定时器，如果没有收到对端的 ACK 包将进行重传。")]),t._v(" "),s("p",[t._v("可以用一个最简单的 packetdrill 脚本来模拟这个场景")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("+0   socket(..., SOCK_STREAM, IPPROTO_TCP) = 3\n")])])]),s("p",[t._v("​"),s("br"),t._v("\n+0 connect(3, ..., ...) = -1")]),t._v(" "),s("p",[t._v("抓包结果如下")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/29/16b03db345b63f36",alt:""}})]),t._v(" "),s("p",[t._v("在我的电脑上，将重传 6 次（间隔 1s、2s、4s、8s、16s、32s），6 次重试以后放弃重试，connect 调用返回 -1，调用超时，")]),t._v(" "),s("p",[t._v("这个值是由/proc/sys/net/ipv4/tcp_syn_retries决定的， 在我的 Centos 机器上，这个值等于 6")]),t._v(" "),s("p",[t._v("整个过程如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/29/16b03db33ad849aa",alt:""}})]),t._v(" "),s("p",[t._v("如果是用 Java 语言就会返回"),s("code",[t._v("java.net.ConnectException: Connection timed out")]),t._v("异常")]),t._v(" "),s("h2",{attrs:{id:"_0x02-重传定时器-retransmission"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x02-重传定时器-retransmission"}},[t._v("#")]),t._v(" 0x02 重传定时器（retransmission）")]),t._v(" "),s("p",[t._v("第一个定时器讲的是连接建立没有收到 ACK 的情况，如果在发送数据包的时候没有收到 ACK 呢？这就是这里要讲的第二个定时器重传定时器。重传定时器在之前的文章中有专门一篇文章介绍，重传定时器的时间是动态计算的，取决于 RTT 和重传的次数。")]),t._v(" "),s("p",[t._v("还是用 packetdrill 脚本的方式来模拟")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[t._v("0   socket(..., SOCK_STREAM, IPPROTO_TCP) = 3\n+0  setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\n+0  bind(3, ..., ...) = 0\n+0  listen(3, 1) = 0\n")])])]),s("p",[t._v("​"),s("br"),t._v("\n+0  < S 0:0(0) win 4000 <mss 1000>\n+0  > S. 0:0(0) ack 1 <...>\n+.1 < . 1:1(0) ack 1 win 4000\n+0  accept(3, ..., ...) = 4")]),t._v(" "),s("p",[t._v("​"),s("br"),t._v("\n+0  write(4, ..., 1000) = 1000")]),t._v(" "),s("p",[t._v("​"),s("br"),t._v("\n​"),s("br"),t._v("\n​"),s("br"),t._v("\n+0 "),s("code",[t._v("sleep 1000000")])]),t._v(" "),s("p",[t._v("抓包结果如下")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/29/16b03db34688732e",alt:""}})]),t._v(" "),s("p",[t._v("重传时间间隔是指数级退避，直到达到 120s 为止，重传次数是15次（这个值由操作系统的 "),s("code",[t._v("/proc/sys/net/ipv4/tcp_retries2")]),t._v(" 决定)，总时间将近 15 分钟。")]),t._v(" "),s("p",[t._v("整个过程如下图")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/29/16b03db344f0a4c2",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"_0x03-延迟-ack-定时器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x03-延迟-ack-定时器"}},[t._v("#")]),t._v(" 0x03 延迟 ACK 定时器")]),t._v(" "),s("p",[t._v("在 TCP 收到数据包以后在没有数据包要回复时，不马上回复 ACK。这时开启一个定时器，等待一段时间看是否有数据需要回复。如果期间有数据要回复，则在回复的数据中捎带 ACK，如果时间到了也没有数据要发送，则也发送 ACK。在 Centos7 上这个值为 40ms。这里在延迟确认章节有详细的介绍，不再展开。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/29/16b040aecfbd6973",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"_0x04-坚持计时器-persist-timer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x04-坚持计时器-persist-timer"}},[t._v("#")]),t._v(" 0x04 坚持计时器（persist timer）")]),t._v(" "),s("p",[t._v("坚持计时器这个翻译真是很奇葩，下面我用 Persist 定时器来讲述。")]),t._v(" "),s("p",[t._v("Persist 定时器是专门为零窗口探测而准备的。我们都知道 TCP 利用滑动窗口来实现流量控制，当接收端 B 接收窗口为 0 时，发送端 A 此时不能再发送数据，发送端此时开启 Persist 定时器，超时后发送一个特殊的报文给接收端看对方窗口是否已经恢复，这个特殊的报文只有一个字节。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/29/16b03db33d817bb4",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"_0x05-保活定时器-keepalive-timer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x05-保活定时器-keepalive-timer"}},[t._v("#")]),t._v(" 0x05 保活定时器（keepalive timer）")]),t._v(" "),s("p",[t._v("如果通信以后一段时间有再也没有传输过数据，怎么知道对方是不是已经挂掉或者重启了呢？于是 TCP 提出了一个做法就是在连接的空闲时间超过 2 小时，会发送一个探测报文，如果对方有回复则表示连接还活着，对方还在，如果经过几次探测对方都没有回复则表示连接已失效，客户端会丢弃这个连接。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/29/16b03db3485c3a88",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"_0x06-fin-wait-2-定时器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x06-fin-wait-2-定时器"}},[t._v("#")]),t._v(" 0x06 FIN_WAIT_2 定时器")]),t._v(" "),s("p",[t._v("四次挥手过程中，主动关闭的一方收到 ACK 以后从 FIN_WAIT_1 进入 FIN_WAIT_2 状态等待对端的 FIN 包的到来，FIN_WAIT_2 定时器的作用是防止对方一直不发送 FIN 包，防止自己一直傻等。这个值由"),s("code",[t._v("/proc/sys/net/ipv4/tcp_fin_timeout")]),t._v(" 决定，在我的 Centos7 机器上，这个值为 60s")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/29/16b040aecfc3c926",alt:""}})]),t._v(" "),s("h2",{attrs:{id:"_0x07-time-wait-定时器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x07-time-wait-定时器"}},[t._v("#")]),t._v(" 0x07 TIME_WAIT 定时器")]),t._v(" "),s("p",[t._v("TIME_WAIT 定时器也称为 2MSL 定时器，可能是这七个里面名气最大的，主动关闭连接的一方在 TIME_WAIT 持续 2 个 MSL 的时间，超时后端口号可被安全的重用。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/29/16b03db46b133519",alt:""}})]),t._v(" "),s("p",[t._v("TIME_WAIT存在的意义有两个：")]),t._v(" "),s("ul",[s("li",[t._v("可靠的实现 TCP 全双工的连接终止（处理最后 ACK 丢失的情况）")]),t._v(" "),s("li",[t._v("避免当前关闭连接与后续连接混淆（让旧连接的包在网络中消逝）")])]),t._v(" "),s("h2",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),s("p",[t._v("以上就是 TCP 的 7 个定时器的全部内容，每一个的细节都在之前的文章中有详细的介绍，如果有不太明白的地方可以翻阅")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://juejin.im/book/6844733788681928712/section/6844733788849700877",target:"_blank",rel:"noopener noreferrer"}},[t._v("Source"),s("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=v.exports}}]);