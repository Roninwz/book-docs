(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{393:function(t,e,n){"use strict";n.r(e);var r=n(54),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("TCP 的自连接是一个比较有意思的现象，甚至很多人认为是 Linux 内核的 bug。我们先来看看 TCP 的自连接是什么。")]),t._v(" "),n("h2",{attrs:{id:"tcp-自连接是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tcp-自连接是什么"}},[t._v("#")]),t._v(" TCP 自连接是什么")]),t._v(" "),n("p",[t._v("新建一个脚本 self_connect.sh，内容如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("while true\ndo\n\tnc 127.0.0.1 50000\ndone\n")])])]),n("p",[t._v("执行这段脚本之前先用 netstat 等命令确认 50000 没有进程监听。然后执行脚本，经过一段时间，telnet 居然成功了。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("Trying 127.0.0.1...\ntelnet: connect to address 127.0.0.1: Connection refused\nTrying 127.0.0.1...\ntelnet: connect to address 127.0.0.1: Connection refused\nTrying 127.0.0.1...\nConnected to 127.0.0.1.\nEscape character is '^]'.\n")])])]),n("p",[t._v("使用 netstat 查看当前的 50000 端口的连接状况，如下所示。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 127.0.0.1:50000         127.0.0.1:50000         ESTABLISHED 24786/telnet\n")])])]),n("p",[t._v("可以看到源 IP、源端口是 "),n("code",[t._v("127.0.0.1:50000")]),t._v("，目标 ip、目标端口也是 "),n("code",[t._v("127.0.0.1:50000")]),t._v("，通过上面的脚本，我们连上了本来没有监听的端口号。")]),t._v(" "),n("h2",{attrs:{id:"自连接原因分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自连接原因分析"}},[t._v("#")]),t._v(" 自连接原因分析")]),t._v(" "),n("p",[t._v("自连接成功的抓包结果如下图所示。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/31/16ffa47400ab009c",alt:""}})]),t._v(" "),n("p",[t._v("对于自连接而言，上图中 wireshark 中的每个包的发送接收双方都是自己，所以可以理解为总共是六个包，包的交互过程如下图所示。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2020/1/31/16ffa47403b85491",alt:"自连接包交互过程"}})]),t._v(" "),n("p",[t._v("这个图是不是似曾相识？前四个包的交互过程就是 TCP 同时打开的过程。")]),t._v(" "),n("p",[t._v("当一方主动发起连接时，操作系统会自动分配一个临时端口号给连接主动发起方。如果刚好分配的临时端口是 50000 端口，过程如下。")]),t._v(" "),n("ul",[n("li",[t._v("第一个包是发送 SYN 包给 50000 端口")]),t._v(" "),n("li",[t._v("对于发送方而已，它收到了这个 SYN 包，以为对方是想同时打开，会回复 SYN+ACK")]),t._v(" "),n("li",[t._v("回复 SYN+ACK 以后，它自己就会收到这个 SYN+ACK，以为是对方回的，对它而已握手成功，进入 ESTABLISHED 状态")])]),t._v(" "),n("h2",{attrs:{id:"自连接的危害"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自连接的危害"}},[t._v("#")]),t._v(" 自连接的危害")]),t._v(" "),n("p",[t._v("设想一个如下的场景：")]),t._v(" "),n("ul",[n("li",[t._v("你写的业务系统 B 会访问本机服务 A，服务 A 监听了 50000 端口")]),t._v(" "),n("li",[t._v("业务系统 B 的代码写的稍微比较健壮，增加了对服务 A 断开重连的逻辑")]),t._v(" "),n("li",[t._v("如果有一天服务 A 挂掉比较长时间没有启动，业务系统 B 开始不断 connect 重连")]),t._v(" "),n("li",[t._v("系统 B 经过一段时间的重试就会出现自连接的情况")]),t._v(" "),n("li",[t._v("这时服务 A 想启动监听 50000 端口就会出现地址被占用的异常，无法正常启动")])]),t._v(" "),n("p",[t._v("如果出现了自连接，至少有两个显而易见的问题：")]),t._v(" "),n("ul",[n("li",[t._v("自连接的进程占用了端口，导致真正需要监听端口的服务进程无法监听成功")]),t._v(" "),n("li",[t._v("自连接的进程看起来 connect 成功，实际上服务是不正常的，无法正常进行数据通信")])]),t._v(" "),n("h2",{attrs:{id:"如何解决自连接问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何解决自连接问题"}},[t._v("#")]),t._v(" 如何解决自连接问题")]),t._v(" "),n("p",[t._v("自连接比较罕见，但一旦出现逻辑上就有问题了，因此要尽量避免。解决自连接有两个常见的办法。")]),t._v(" "),n("ul",[n("li",[t._v("让服务监听的端口与客户端随机分配的端口不可能相同即可")]),t._v(" "),n("li",[t._v("出现自连接的时候，主动关掉连接")])]),t._v(" "),n("p",[t._v("对于第一种方法，客户端随机分配的范围由 "),n("code",[t._v("/proc/sys/net/ipv4/ip_local_port_range")]),t._v(" 文件决定，在我的 Centos 8 上，这个值的范围是 32768~60999，只要服务监听的端口小于 32768 就不会出现客户端与服务端口相同的情况。这种方式比较推荐。")]),t._v(" "),n("p",[t._v("对于第二种方法，我第一次见是在 Golang 的 TCP connect 的代码，代码如下所示。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('func (sd *sysDialer) doDialTCP(ctx context.Context, laddr, raddr *TCPAddr) (*TCPConn, error) {\n\tfd, err := internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_STREAM, 0, "dial", sd.Dialer.Control)\n\n\t// TCP has a rarely used mechanism called a \'simultaneous connection\' in\n\t// which Dial("tcp", addr1, addr2) run on the machine at addr1 can\n\t// connect to a simultaneous Dial("tcp", addr2, addr1) run on the machine\n\t// at addr2, without either machine executing Listen. If laddr == nil,\n\t// it means we want the kernel to pick an appropriate originating local\n\t// address. Some Linux kernels cycle blindly through a fixed range of\n\t// local ports, regardless of destination port. If a kernel happens to\n\t// pick local port 50001 as the source for a Dial("tcp", "", "localhost:50001"),\n\t// then the Dial will succeed, having simultaneously connected to itself.\n\t// This can only happen when we are letting the kernel pick a port (laddr == nil)\n\t// and when there is no listener for the destination address.\n\t// It\'s hard to argue this is anything other than a kernel bug. If we\n\t// see this happen, rather than expose the buggy effect to users, we\n\t// close the fd and try again. If it happens twice more, we relent and\n\t// use the result. See also:\n\t//\thttps://golang.org/issue/2690\n\t//\thttps://stackoverflow.com/questions/4949858/\n\t//\n\t// The opposite can also happen: if we ask the kernel to pick an appropriate\n\t// originating local address, sometimes it picks one that is already in use.\n\t// So if the error is EADDRNOTAVAIL, we have to try again too, just for\n\t// a different reason.\n\t//\n\t// The kernel socket code is no doubt enjoying watching us squirm.\n\tfor i := 0; i < 2 && (laddr == nil || laddr.Port == 0) && (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ {\n\t\tif err == nil {\n\t\t\tfd.Close()\n\t\t}\n\t\tfd, err = internetSocket(ctx, sd.network, laddr, raddr, syscall.SOCK_STREAM, 0, "dial", sd.Dialer.Control)\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn newTCPConn(fd), nil\n}\n\nfunc selfConnect(fd *netFD, err error) bool {\n\t// If the connect failed, we clearly didn\'t connect to ourselves.\n\tif err != nil {\n\t\treturn false\n\t}\n\n\t// The socket constructor can return an fd with raddr nil under certain\n\t// unknown conditions. The errors in the calls there to Getpeername\n\t// are discarded, but we can\'t catch the problem there because those\n\t// calls are sometimes legally erroneous with a "socket not connected".\n\t// Since this code (selfConnect) is already trying to work around\n\t// a problem, we make sure if this happens we recognize trouble and\n\t// ask the DialTCP routine to try again.\n\t// TODO: try to understand what\'s really going on.\n\tif fd.laddr == nil || fd.raddr == nil {\n\t\treturn true\n\t}\n\tl := fd.laddr.(*TCPAddr)\n\tr := fd.raddr.(*TCPAddr)\n\treturn l.Port == r.Port && l.IP.Equal(r.IP)\n}\n')])])]),n("p",[t._v("这里详细解释了为什么有 selfConnect 方法的判断，判断是否是自连接的逻辑是判断源 IP 和目标 IP 是否相等，源端口号和目标端口号是否相等。")]),t._v(" "),n("h2",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),n("p",[t._v("到这里，TCP 自连接的知识就介绍完了，在以后写 web 服务监听端口时，记得看下机器上的端口范围，不要胡来。")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/book/6844733788681928712/section/6844733788824535048",target:"_blank",rel:"noopener noreferrer"}},[t._v("Source"),n("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=a.exports}}]);