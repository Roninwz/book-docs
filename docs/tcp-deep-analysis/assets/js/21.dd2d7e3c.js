(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{405:function(t,s,a){"use strict";a.r(s);var n=a(54),c=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"重传示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重传示例"}},[t._v("#")]),t._v(" 重传示例")]),t._v(" "),a("p",[t._v("下面用 packetdrill 来演示丢包重传，模拟的场景如下图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f8781a5d1b94",alt:""}})]),t._v(" "),a("p",[t._v("packetdrill 脚本如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("  1 0   socket(..., SOCK_STREAM, IPPROTO_TCP) = 3\n  2 +0  setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\n  3 +0  bind(3, ..., ...) = 0\n  4 +0  listen(3, 1) = 0\n  5\n  6 // 三次握手\n  7 +0  < S 0:0(0) win 4000 <mss 1000>\n  8 +0  > S. 0:0(0) ack 1 <...>\n  9 +.1 < . 1:1(0) ack 1 win 4000\n 10 +0  accept(3, ..., ...) = 4\n 11\n 12 // 往 fd 为 4 的 socket 文件句柄写入 1000 个字节数据（也即向客户端发送数据）\n 13 +0  write(4, ..., 1000) = 1000\n 14\n 15 // 注释掉 向协议栈注入 ACK 包的代码，模拟客户端不回 ACK 包的情况\n 16 // +.1 < . 1:1(0) ack 1001 win 1000\n 17\n 18 +0 `sleep 1000000`\n")])])]),a("ul",[a("li",[t._v("1 ~ 4 行：新建 socket + bind + listen")]),t._v(" "),a("li",[t._v("7 ~ 9 行：三次握手 + accept 新的连接")]),t._v(" "),a("li",[t._v("13 行：服务端往新的 socket 连接上写入 1000 个字节的文件")]),t._v(" "),a("li",[t._v("16 行：正常情况下，客户端应该回复 ACK 包表示此前的 1000 个字节包已经收到，这里注释掉模拟 ACK 包丢失的情况。")])]),t._v(" "),a("p",[t._v("使用 tcpdump 抓包保存为 pcap 格式，后面 wireshark 可以直接查看")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("sudo tcpdump -i any port 8080 -nn -A -w retrans.pcap\n")])])]),a("p",[t._v("使用 wireshark 打开这个 pcap 文件，因为我们想看重传的时间间隔，可以在 wireshark 中设置时间的显示格式为显示包与包直接的实际间隔，更方便的查看重传间隔，步骤如下图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f878200ad2d8",alt:""}})]),t._v(" "),a("p",[t._v("可以看到重传时间间隔是指数级退避，直到达到 120s 为止，总时间将近 15 分钟，重传次数是 15次 ，重传次数默认值由 /proc/sys/net/ipv4/tcp_retries2 决定（等于 15），会根据 RTO 的不同来动态变化。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f8781c8bd6d8",alt:""}})]),t._v(" "),a("p",[t._v("整个过程如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f8781adaf048",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"永远记住-ack-是表示这之前的包都已经全部收到"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#永远记住-ack-是表示这之前的包都已经全部收到"}},[t._v("#")]),t._v(" 永远记住 ACK 是表示这之前的包都已经全部收到")]),t._v(" "),a("p",[t._v("如果发送 5000 个字节的数据包，因为 MSS 的限制每次传输 1000 个字节，分 5 段传输，如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f8781978ccc9",alt:""}})]),t._v(" "),a("p",[t._v("数据包 1 发送的数据正常到达接收端，接收端回复 ACK 1001，表示 seq 为1001之前的数据包都已经收到，下次从1001开始发。 数据包 2（10001：2001）因为某些原因未能到达服务端，其他包正常到达，这时接收端也不能 ack 3 4 5 数据包，因为数据包 2 还没收到，接收端只能回复 ack 1001。")]),t._v(" "),a("p",[t._v("第 2 个数据包重传成功以后服务器会回复5001，表示seq 为 5001 之前的数据包都已经收到了。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f8782193ca90",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"快速重传机制与-sack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快速重传机制与-sack"}},[t._v("#")]),t._v(" 快速重传机制与 SACK")]),t._v(" "),a("p",[t._v("文章一开始我们介绍了重传的时间间隔，要等几百毫秒才会进行第一次重传。聪明的网络协议设计者们想到了一种方法："),a("strong",[t._v("「快速重传」")]),t._v(" 快速重传的含义是：当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到超时再重传。")]),t._v(" "),a("p",[t._v("这个有一个问题，发送 3、4、5 包收到的全部是 ACK=1001，快速重传解决了一个问题: 需要重传。因为除了 2 号包，3、4、5 包也有可能丢失，那到底是只重传数据包 2 还是重传 2、3、4、5 所有包呢？")]),t._v(" "),a("p",[t._v("聪明的网络协议设计者，想到了一个好办法")]),t._v(" "),a("ul",[a("li",[t._v("收到 3 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 "),a("strong",[t._v("1000")]),t._v("（ACK=1001），[1:1001]、[2001:3001] 区间的包我也收到了")]),t._v(" "),a("li",[t._v("收到 4 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 "),a("strong",[t._v("1000")]),t._v("（ACK=1001），[1:1001]、[2001:4001] 区间的包我也收到了")]),t._v(" "),a("li",[t._v("收到 5 号包的时候在 ACK 包中告诉发送端：喂，小老弟，我目前收到的最大连续的包序号是 "),a("strong",[t._v("1000")]),t._v("（ACK=1001），[1:1001]、[2001:5001] 区间的包我也收到了")])]),t._v(" "),a("p",[t._v("这样发送端就清楚知道只用重传 2 号数据包就可以了，数据包 3、4、5已经确认无误被对端收到。这种方式被称为 SACK（Selective Acknowledgment）。")]),t._v(" "),a("p",[t._v("如下图所示：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f8785971515d",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"使用-packetdrill-演示快速重传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-packetdrill-演示快速重传"}},[t._v("#")]),t._v(" 使用 packetdrill 演示快速重传")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("  1 --tolerance_usecs=100000\n  // 常规操作：初始化\n  2 0  socket(..., SOCK_STREAM, IPPROTO_TCP) = 3\n  3 +0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\n  4 +0 bind(3, ..., ...) = 0\n  5 +0 listen(3, 1) = 0\n  6\n  7 +0  < S 0:0(0) win 32792 <mss 1000,sackOK,nop,nop,nop,wscale 7>\n  8 +0  > S. 0:0(0) ack 1 <...>\n  9 +.1 < . 1:1(0) ack 1 win 257\n 10\n 11 +0 accept(3, ... , ...) = 4\n 12 // 往客户端写 5000 字节数据\n 13 +0.1 write(4, ..., 5000) = 5000\n 14\n 15 +.1 < . 1:1(0) ack 1001 win 257 <sack 1:1001,nop,nop>\n // 三次重复 ack\n 16 +0  < . 1:1(0) ack 1001 win 257 <sack 1:1001 2001:3001,nop,nop>\n 17 +0  < . 1:1(0) ack 1001 win 257 <sack 1:1001 2001:4001,nop,nop>\n 18 +0  < . 1:1(0) ack 1001 win 257 <sack 1:1001 2001:5001,nop,nop>\n 19 // 回复确认包，让服务端不再重试\n 20 +.1 < . 1:1(0) ack 5001 win 257\n 21\n 22 +0 `sleep 1000000`\n")])])]),a("p",[t._v("用 tcpdump 抓包以供 wireshark 分析"),a("code",[t._v("sudo tcpdump -i any port 8080 -nn -A -w fast_retran.pcap")]),t._v("，使用 packetdrill 执行上面的脚本。 可以看到，完全符合我们的预期，3 次重复 ACK 以后，过了15微妙，立刻进行了重传")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f878595513f8",alt:""}})]),t._v(" "),a("p",[t._v("打开单个包的详情，在 ACK 包的 option 选项里，包含了 SACK 的信息，如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/27/1692f878596b44a2",alt:""}})]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.im/book/6844733788681928712/section/6844733788837134350",target:"_blank",rel:"noopener noreferrer"}},[t._v("Source"),a("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=c.exports}}]);