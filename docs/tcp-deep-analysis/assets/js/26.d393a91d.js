(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{410:function(t,e,n){"use strict";n.r(e);var a=n(54),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("这篇文章我们来介绍延迟确认。")]),t._v(" "),n("p",[t._v("首先必须明确两个观点：")]),t._v(" "),n("ul",[n("li",[t._v("不是每个数据包都对应一个 ACK 包，因为可以合并确认。")]),t._v(" "),n("li",[t._v("也不是接收端收到数据以后必须立刻马上回复确认包。")])]),t._v(" "),n("p",[t._v("如果收到一个数据包以后暂时没有数据要分给对端，它可以等一段时间（Linux 上是 40ms）再确认。如果这段时间刚好有数据要传给对端，ACK 就可以随着数据一起发出去了。如果超过时间还没有数据要发送，也发送 ACK，以免对端以为丢包了。这种方式成为「延迟确认」。")]),t._v(" "),n("p",[t._v("这个原因跟 Nagle 算法其实一样，回复一个空的 ACK 太浪费了。")]),t._v(" "),n("ul",[n("li",[t._v("如果接收端这个时候恰好有数据要回复客户端，那么 ACK 搭上顺风车一块发送。")]),t._v(" "),n("li",[t._v("如果期间又有客户端的数据传过来，那可以把多次 ACK 合并成一个立刻发送出去")]),t._v(" "),n("li",[t._v("如果一段时间没有顺风车，那么没办法，不能让接收端等太久，一个空包也得发。")])]),t._v(" "),n("p",[t._v("这种机制被称为延迟确认（delayed ack），思破哥的文章把延迟确认（delayed-ack）称为「"),n("strong",[t._v("磨叽姐")]),t._v("」，挺形象的。TCP 要求 ACK 延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。")]),t._v(" "),n("p",[t._v("延迟确认在很多 linux 机器上是没有办法关闭的，")]),t._v(" "),n("p",[t._v("那么这里涉及的就是一个非常根本的问题：「收到数据包以后什么时候该回复 ACK」")]),t._v(" "),n("h2",{attrs:{id:"什么时候需要回复-ack"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么时候需要回复-ack"}},[t._v("#")]),t._v(" 什么时候需要回复 ACK")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://elixir.bootlin.com/linux/v2.6.11/source/net/ipv4/tcp_input.c",target:"_blank",rel:"noopener noreferrer"}},[t._v("tcp_input.c"),n("OutboundLink")],1)]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\n\t    /* More than one full frame received... */\n\tif (((tp->rcv_nxt - tp->rcv_wup) > tp->ack.rcv_mss\n\t     /* ... and right edge of window advances far enough.\n\t      * (tcp_recvmsg() will send ACK otherwise). Or...\n\t      */\n\t     && __tcp_select_window(sk) >= tp->rcv_wnd) ||\n\t    /* We ACK each frame or... */\n\t    tcp_in_quickack_mode(tp) ||\n\t    /* We have out of order data. */\n\t    (ofo_possible &&\n\t     skb_peek(&tp->out_of_order_queue))) {\n\t\t/* Then ack it now */\n\t\ttcp_send_ack(sk);\n\t} else {\n\t\t/* Else, send delayed ack. */\n\t\ttcp_send_delayed_ack(sk);\n\t}\n}\n")])])]),n("p",[t._v("可以看到需要立马回复 ACK 的场景有：")]),t._v(" "),n("ul",[n("li",[t._v("如果接收到了大于一个frame 的报文，且需要调整窗口大小")]),t._v(" "),n("li",[t._v("处于 quickack 模式（tcp_in_quickack_mode）")]),t._v(" "),n("li",[t._v("收到乱序包（We have out of order data.）")])]),t._v(" "),n("p",[t._v("其它情况一律使用延迟确认的方式")]),t._v(" "),n("p",[t._v("需要重点关注的是：tcp_in_quickack_mode()")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('/* Send ACKs quickly, if "quick" count is not exhausted\n * and the session is not interactive.\n */\n\nstatic __inline__ int tcp_in_quickack_mode(struct tcp_sock *tp)\n{\n\treturn (tp->ack.quick && !tp->ack.pingpong);\n}\n\n/* Delayed ACK control data */\nstruct {\n\t__u8\tpending;\t/* ACK is pending */\n\t__u8\tquick;\t\t/* Scheduled number of quick acks\t*/\n\t__u8\tpingpong;\t/* The session is interactive\t\t*/\n\t__u8\tblocked;\t/* Delayed ACK was blocked by socket lock*/\n\t__u32\tato;\t\t/* Predicted tick of soft clock\t\t*/\n\tunsigned long timeout;\t/* Currently scheduled timeout\t\t*/\n\t__u32\tlrcvtime;\t/* timestamp of last received data packet*/\n\t__u16\tlast_seg_size;\t/* Size of last incoming segment\t*/\n\t__u16\trcv_mss;\t/* MSS used for delayed ACK decisions\t*/ \n} ack;\n')])])]),n("p",[t._v("内核 tcp_sock 结构体中有一个 ack 子结构体，内部有一个 quick 和 pingpong 两个字段，其中pingpong 就是判断交互连接的，只有处于非交互 TCP 连接才有可能即进入 quickack 模式。")]),t._v(" "),n("p",[t._v("什么是交互式和 pingpong 呢？")]),t._v(" "),n("p",[t._v("顾名思义，其实有来有回的双向数据传输就叫 pingpong，对于通信的某一端来说，"),n("code",[t._v("R-W-R-W-R-W...")]),t._v("（R 表示读，W 表示写）")]),t._v(" "),n("p",[t._v("延迟确认出现的最多的场景是 "),n("code",[t._v("W-W-R")]),t._v("（写写读），我们来分析一下这种场景。")]),t._v(" "),n("h2",{attrs:{id:"延迟确认实际例子演示"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#延迟确认实际例子演示"}},[t._v("#")]),t._v(" 延迟确认实际例子演示")]),t._v(" "),n("p",[t._v("可以用一段 java 代码演示延迟确认。")]),t._v(" "),n("p",[t._v("服务端代码如下，当从服务端 readLine 有返回非空字符串（读到"),n("code",[t._v("\\n 或 \\r")]),t._v("）就把字符串原样返回给客户端")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('public class DelayAckServer {\n    private static final int PORT = 8888;\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket();\n        serverSocket.bind(new InetSocketAddress(PORT));\n        System.out.println("Server startup at " + PORT);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            InputStream inputStream = socket.getInputStream();\n            OutputStream outputStream = socket.getOutputStream();\n            int i = 1;\n            while (true) {\n                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n                String line = reader.readLine();\n                if (line == null) break;\n                System.out.println((i++) + " : " + line);\n                outputStream.write((line + "\\n").getBytes());\n            }\n        }\n    }\n}\n')])])]),n("p",[t._v("下面是客户端代码，客户端分两次调用 write 方法，模拟 http 请求的 header 和 body。第二次 write 包含了换行符（\\n)，然后测量 write、write、read 所花费的时间。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('public class DelayAckClient {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket();\n        socket.connect(new InetSocketAddress("server_ip", 8888));\n        InputStream inputStream = socket.getInputStream();\n        OutputStream outputStream = socket.getOutputStream();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n        String head = "hello, ";\n        String body = "world\\n";\n\n        for (int i = 0; i < 10; i++) {\n            long start = System.currentTimeMillis();\n            outputStream.write(("#" + i + " " + head).getBytes()); \n            outputStream.write((body).getBytes()); \n            String line = reader.readLine(); \n            System.out.println("RTT: " + (System.currentTimeMillis() - start) + ": " + line);\n        }\n        inputStream.close();\n        outputStream.close();\n        socket.close();\n    }\n}\n')])])]),n("p",[t._v("运行结果如下")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("javac DelayAckClient.java; java -cp . DelayAckClient\nRTT: 1: \nRTT: 44: \nRTT: 46: \nRTT: 44: \nRTT: 42: \nRTT: 41: \nRTT: 41: \nRTT: 44: \nRTT: 44: \nRTT: 44: \n")])])]),n("p",[t._v("除了第一次，剩下的 RTT 全为 40 多毫秒。这刚好是 Linux 延迟确认定时器的时间 40ms 抓包结果如下:")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/9/16a006acf0a4e73f",alt:""}})]),t._v(" "),n("p",[t._v("对包逐个分析一下 1 ~ 3：三次握手 4 ~ 9：第一次 for 循环的请求，也就是 W-W-R 的过程")]),t._v(" "),n("ul",[n("li",[t._v('4：客户端发送 "#0 hello, " 给服务端')]),t._v(" "),n("li",[t._v("5：因为服务端只收到了数据还没有回复过数据，tcp 判断不是 pingpong 的交互式数据，属于 quickack 模式，立刻回复 ACK")]),t._v(" "),n("li",[t._v('6：客户端发送 "world\\n" 给服务端')]),t._v(" "),n("li",[t._v("7：服务端因为还没有回复过数据，tcp 判断不是 pingpong 的交互式数据，服务端立刻回复 ACK")]),t._v(" "),n("li",[t._v("8：服务端读到换行符，readline 函数返回，会把读到的字符串原样写入到客户端。TCP 这个时候检测到是 pingpong 的交互式连接，进入延迟确认模式")]),t._v(" "),n("li",[t._v("9：客户端收到数据以后回复 ACK")])]),t._v(" "),n("p",[t._v("10 ~ 14：第二次 for 循环")]),t._v(" "),n("ul",[n("li",[t._v('10：客户端发送 "#1 hello, " 给服务端。服务端收到数据包以后，因为处于 pingpong 模式，开启一个 40ms 的定时器，奢望在 40ms 内有数据回传')]),t._v(" "),n("li",[t._v("11：很不幸，服务端等了 40ms 定期器到期都没有数据回传，回复确认 ACK 同时取消 pingpong 状态")]),t._v(" "),n("li",[t._v('12：客户端发送 "world\\n" 给服务端')]),t._v(" "),n("li",[t._v("13：因为服务端不处于 pingpong 状态，所以收到数据立即回复 ACK")]),t._v(" "),n("li",[t._v("14：服务端读到换行符，readline 函数返回，会把读到的字符串原样写入到客户端。这个时候又检测到收发数据了，进入 pingpong 状态。")])]),t._v(" "),n("p",[t._v("从第二次 for 开始，后面的数据包都一样了。 整个过程包交互图如下：")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/9/16a006ace9ddc4ef",alt:""}})]),t._v(" "),n("h2",{attrs:{id:"用-packetdrill-模拟延迟确认"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#用-packetdrill-模拟延迟确认"}},[t._v("#")]),t._v(" 用 packetdrill 模拟延迟确认")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('--tolerance_usecs=100000\n0.000 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3\n0.000 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0\n0.000 bind(3, ..., ...) = 0\n0.000 listen(3, 1) = 0\n\n0.000 < S 0:0(0) win 32792 <mss 1000, sackOK, nop, nop, nop, wscale 7>\n0.000 > S. 0:0(0) ack 1 <...>\n\n0.000 < . 1:1(0) ack 1 win 257\n\n0.000 accept(3, ..., ...) = 4\n\n+ 0 setsockopt(4, SOL_TCP, TCP_NODELAY, [1], 4) = 0\n\n// 模拟往服务端写入 HTTP 头部: POST / HTTP/1.1\n+0 < P. 1:11(10) ack 1 win 257\n\n// 模拟往服务端写入 HTTP 请求 body: {"id": 1314}\n+0 < P. 11:26(15) ack 1 win 257\n\n// 往 fd 为4 的 模拟服务器返回 HTTP response {}\n+ 0 write(4, ..., 100) = 100\n')])])]),n("p",[t._v("​"),n("br"),t._v("\n// 第二次模拟往服务端写入 HTTP 头部: POST / HTTP/1.1\n+0 < P. 26:36(10) ack 101 win 257")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("// 抓包看服务器返回\n\n+0 `sleep 1000000`\n")])])]),n("p",[t._v("这个构造包的过程跟前面的思路是一模一样的，抓包同样复现了 40ms 延迟的现象。")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/9/16a006acecf83ba7",alt:""}})]),t._v(" "),n("h2",{attrs:{id:"可以设置关掉延迟确认吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#可以设置关掉延迟确认吗"}},[t._v("#")]),t._v(" 可以设置关掉延迟确认吗？")]),t._v(" "),n("p",[t._v("这个是我刚开始学习 TCP 的一个疑惑，既然是 TCP 的一个特性，那有没有一个开关可以开启或者关闭延迟确认呢？ 答案是否定的，大部分 Linux 实现上并没有开关可以关闭延迟确认。我曾经以为它是一个 sysctl 项，可是后来找了很久都没有找到，没有办法通过一个配置彻底关掉或者开启 Linux 的延迟确认。")]),t._v(" "),n("h2",{attrs:{id:"当-nagle-算法遇到延迟确认"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#当-nagle-算法遇到延迟确认"}},[t._v("#")]),t._v(" 当 Nagle 算法遇到延迟确认")]),t._v(" "),n("p",[t._v("Nagle 算法和延迟确认本身并没有什么问题，但一起使用就会出现很严重的性能问题了。Nagle 攒着包一次发一个，延迟确认收到包不马上回。")]),t._v(" "),n("p",[t._v("如果我们把上面的 Java 代码稍作调整，禁用 Nagle 算法可以试一下。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v('Socket socket = new Socket();\nsocket.setTcpNoDelay(true); // 禁用 Nagle 算法\nsocket.connect(new InetSocketAddress("server ip", 8888));\n')])])]),n("p",[t._v("运行 Client 端，可以看到 RTT 几乎为 0")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("RTT: 1: \nRTT: 0: \nRTT: 1: \nRTT: 1: \nRTT: 0: \nRTT: 1: \nRTT: 1: \nRTT: 0: \nRTT: 1: \nRTT: 0: \n")])])]),n("p",[t._v("抓包结果如下")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/4/9/16a006aceed2734f",alt:""}})]),t._v(" "),n("p",[t._v("黑色背景部分的是客户端发送给服务端的请求包，可以看到在禁用 Nagle 的情况下，不用等一个包发完再发下一个，而是几乎同时把两次写请求发送出来了。服务端收到带换行符的包以后，立马可以返回结果，ACK 可以捎带过去，就不会出现延迟 40ms 的情况。")]),t._v(" "),n("h2",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),n("p",[t._v("这篇文章主要介绍了延迟确认出现的背景和原因，然后用一个实际的代码演示了延迟确认的具体的细节。到这里 Nagle 算法和延迟确认这两个主题就介绍完毕了。")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/book/6844733788681928712/section/6844733788845506573",target:"_blank",rel:"noopener noreferrer"}},[t._v("Source"),n("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);