(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{400:function(e,t,s){"use strict";s.r(t);var a=s(54),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("前面介绍到四次挥手的时候有讲到，"),s("strong",[e._v("主动断开")]),e._v("连接的那一端需要等待 2 个 MSL 才能最终释放这个连接。一般而言，主动断开连接的都是客户端，如果是服务端程序重启或者出现 bug 崩溃，这时服务端会主动断开连接，如下图所示")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/25/169230452f26de90",alt:""}})]),e._v(" "),s("p",[e._v("因为要等待 2 个 MSL 才能最终释放连接，所以如果这个时候程序马上启动，就会出现"),s("code",[e._v("Address already in use")]),e._v("错误。要过 1 分钟以后才可以启动成功。如果你写了一个 web 服务器，崩溃以后被脚本自动拉起失败，需要等一分钟才正常，运维可能要骂娘了。")]),e._v(" "),s("p",[e._v("下面来写一段简单的代码演示这个场景是如何产生的。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('public class ReuseAddress {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket();\n        \n        serverSocket.setReuseAddress(false);\n        serverSocket.bind(new InetSocketAddress(8080));\n        System.out.println("reuse address: " + serverSocket.getReuseAddress());\n        while (true) {\n            Socket socket = serverSocket.accept();\n            System.out.println("incoming socket..");\n            OutputStream out = socket.getOutputStream();\n            out.write("Hello\\n".getBytes());\n            out.close();\n        }\n    }\n}\n')])])]),s("p",[e._v('这段代码的功能是启动一个 TCP 服务器，客户端连上来就返回了一个 "Hello\\n" 回去。')]),e._v(" "),s("p",[e._v("使用 javac 编译 class 文件"),s("code",[e._v("javac ReuseAddress.java;")]),e._v("，然后用 java 命令运行"),s("code",[e._v("java -cp . ReuseAddress")]),e._v("。使用 nc 命令连接 8080 端口"),s("code",[e._v("nc localhost 8080")]),e._v('，应该会马上收到服务端返回的"Hello\\n"字符串。现在 kill 这个进程，马上重启这个程序就可以看到程序启动失败，报 socket bind 失败，堆栈如下：')]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v('Exception in thread "main" java.net.BindException: 地址已在使用 (Bind failed)\n\tat java.net.PlainSocketImpl.socketBind(Native Method)\n\tat java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:387)\n\tat java.net.ServerSocket.bind(ServerSocket.java:375)\n\tat java.net.ServerSocket.bind(ServerSocket.java:329)\n\tat ReuseAddress.main(ReuseAddress.java:18)\n')])])]),s("p",[e._v("将代码修改为"),s("code",[e._v("serverSocket.setReuseAddress(true);")]),e._v("，再次重复上面的测试过程，再也不会出现上述异常了。")]),e._v(" "),s("h2",{attrs:{id:"_0x02-为什么需要-so-reuseaddr-参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x02-为什么需要-so-reuseaddr-参数"}},[e._v("#")]),e._v(" 0x02 为什么需要 SO_REUSEADDR 参数")]),e._v(" "),s("p",[e._v("服务端主动断开连接以后，需要等 2 个 MSL 以后才最终释放这个连接，重启以后要绑定同一个端口，默认情况下，操作系统的实现都会阻止新的监听套接字绑定到这个端口上。")]),e._v(" "),s("p",[e._v("我们都知道 TCP 连接由四元组唯一确定。形式如下")]),e._v(" "),s("p",[e._v("{local-ip-address:local-port , foreign-ip-address:foreign-port}")]),e._v(" "),s("p",[e._v("一个典型的例子如下图")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/25/169230452a3ad54a",alt:""}})]),e._v(" "),s("p",[e._v("TCP 要求这样的四元组必须是唯一的，但大多数操作系统的实现要求更加严格，只要还有连接在使用这个本地端口，则本地端口不能被重用（bind 调用失败）")]),e._v(" "),s("p",[e._v("启用 SO_REUSEADDR 套接字选项可以解除这个限制，默认情况下这个值都为 0，表示关闭。在 Java 中，reuseAddress 不同的 JVM 有不同的实现，在我本机上，这个值默认为 1 允许端口重用。但是为了保险起见，写 TCP、HTTP 服务一定要主动设置这个参数为 1。")]),e._v(" "),s("h2",{attrs:{id:"_0x03-是不是只有处于-time-wait-才允许端口复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x03-是不是只有处于-time-wait-才允许端口复用"}},[e._v("#")]),e._v(" 0x03 是不是只有处于 TIME_WAIT 才允许端口复用？")]),e._v(" "),s("p",[e._v("查看 Java 中 ServerSocket.setReuseAddress 的文档，有如下的说明")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("/**\n * Enable/disable the {@link SocketOptions\n * socket option.\n * <p>\n * When a TCP connection is closed the connection may remain\n * in a timeout state for a period of time after the connection\n * is closed (typically known as the {@code TIME_WAIT} state\n * or {@code 2MSL} wait state).\n * For applications using a well known socket address or port\n * it may not be possible to bind a socket to the required\n * {@code SocketAddress} if there is a connection in the\n * timeout state involving the socket address or port.\n* /\n")])])]),s("p",[e._v("假设因为网络的原因，客户端没有回发 FIN 包，导致服务器端处于 FIN_WAIT2 状态，而非 TIME_WAIT 状态，那设置 SO_REUSEADDR 还会生效吗？")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/2/25/169252c596fbaac0",alt:""}})]),e._v(" "),s("p",[e._v("来做一个实验，现在有两台机器c1（充当客户端），c2（充当服务器）。在客户端 c1 利用防火墙拦截掉所有发出的 FIN 包："),s("code",[e._v("sudo iptables --append OUTPUT --match tcp --protocol tcp --dport 8080 --tcp-flags FIN FIN --jump DROP")]),e._v("。 在c1 上使用"),s("code",[e._v("nc c2 8080")]),e._v("发起 tcp 连接，随后杀掉 c2 的进程， 因为服务端收不到客户端发过来的 FIN 包，也即四次挥手中的第 3 步没能成功，服务端此时将处于 FIN_WAIT2 状态。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("ya@c2 ~$ sudo netstat -lnpa  | grep 8080\ntcp6       0      0 10.211.55.10:8080       10.211.55.5:39664       FIN_WAIT2   -\n")])])]),s("p",[e._v("将 SO_REUSEADDR 设置为 1，重复上面的测试过程，将发现不会出现异常。将 SO_REUSEADDR 设置为 0，则会出现 Address already in use 异常。")]),e._v(" "),s("p",[e._v("因此，不一定是要处于 TIME_WAIT 才允许端口复用的，只是大都是情况下，主动关闭连接的服务端都会处于 TIME_WAIT。如果不把 SO_REUSEADDR 设置为 1，服务器将等待 2 个 MSL 才可以重新绑定原端口")]),e._v(" "),s("h2",{attrs:{id:"_0x04-为什么通常不会在客户端上出现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_0x04-为什么通常不会在客户端上出现"}},[e._v("#")]),e._v(" 0x04 为什么通常不会在客户端上出现")]),e._v(" "),s("p",[e._v("通常情况下都是客户端主动关闭连接，那客户端那边为什么不会有问题呢？")]),e._v(" "),s("p",[e._v("因为客户端都是用的临时端口，这些临时端口与处于 TIME_WAIT 状态的端口恰好相同的可能性不大，就算相同换一个新的临时端口就好了。")]),e._v(" "),s("h2",{attrs:{id:"小结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),s("p",[e._v("这篇文章主要讲了 SO_REUSEADDR 套接字属性出现的背景和分析，随后讲解了为什么需要 SO_REUSEADDR 参数，以及为什么客户端不需要关心这个参数。")]),e._v(" "),s("p",[e._v("如果你看这篇文章有什么疑问，欢迎你在留言区留言。")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://juejin.im/book/6844733788681928712/section/6844733788832940039",target:"_blank",rel:"noopener noreferrer"}},[e._v("Source"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);