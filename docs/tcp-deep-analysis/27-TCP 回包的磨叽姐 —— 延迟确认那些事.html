<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>技术文档</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="技术文档">
    
    <link rel="preload" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.0ea9dfb1.css" as="style"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/app.411d3f03.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" as="script"><link rel="preload" href="/book-docs/tcp-deep-analysis/assets/js/26.79028ade.js" as="script"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/10.f0096057.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/11.afe0018d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/12.8691dd56.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/13.4570bab2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/14.6bb5eaad.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/15.d523fd97.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/16.be91c86f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/17.4f301f0a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/18.e0b82547.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/19.1c34c4fb.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/20.5b297df0.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/21.1e4f6afa.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/22.1fd8c44a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/23.4806d06d.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/24.64abf514.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/25.1db6ae87.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/27.49378cc8.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/28.3f365d4e.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/29.9e4d2797.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/3.874bed90.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/30.4e5f15e1.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/31.b0e97354.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/32.5ebf2421.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/33.75327db6.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/34.6fcf5c05.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/35.2076a0c2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/36.db825ac9.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/37.3ce92f36.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/38.4afa2433.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/39.e7e9657a.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/4.0892ecd3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/40.c62d5047.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/41.69a88bf2.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/42.e6229e54.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/43.e36841dc.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/44.8e5155d3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/45.4c2a7d70.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/46.9ae4ac37.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/47.a075a79f.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/5.864d5a79.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/6.19b45fc3.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/7.2a1330f4.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/8.8683fe45.js"><link rel="prefetch" href="/book-docs/tcp-deep-analysis/assets/js/9.c6213155.js">
    <link rel="stylesheet" href="/book-docs/tcp-deep-analysis/assets/css/0.styles.0ea9dfb1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/book-docs/tcp-deep-analysis/" class="home-link router-link-active"><!----> <span class="site-name">技术文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/book-docs/tcp-deep-analysis/1-开篇词 —— 小册食用指南.html" class="sidebar-link">1-开篇词 —— 小册食用指南.md</a></li><li><a href="/book-docs/tcp-deep-analysis/2-TCP_IP 历史与分层模型.html" class="sidebar-link">2-TCP_IP 历史与分层模型.md</a></li><li><a href="/book-docs/tcp-deep-analysis/3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.html" class="sidebar-link">3-TCP 概述 —— 可靠的、面向连接的、基于字节流、全双工的协议.md</a></li><li><a href="/book-docs/tcp-deep-analysis/4-来自 Google 的协议栈测试神器 —— packetdrill.html" class="sidebar-link">4-来自 Google 的协议栈测试神器 —— packetdrill.md</a></li><li><a href="/book-docs/tcp-deep-analysis/5-支撑 TCP 协议的基石 —— 剖析首部字段.html" class="sidebar-link">5-支撑 TCP 协议的基石 —— 剖析首部字段.md</a></li><li><a href="/book-docs/tcp-deep-analysis/6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.html" class="sidebar-link">6-数据包大小对网络的影响 —— MTU 与 MSS 的奥秘.md</a></li><li><a href="/book-docs/tcp-deep-analysis/7-繁忙的贸易港口 —— 聊聊端口号.html" class="sidebar-link">7-繁忙的贸易港口 —— 聊聊端口号.md</a></li><li><a href="/book-docs/tcp-deep-analysis/8-临时端口号是如何分配的.html" class="sidebar-link">8-临时端口号是如何分配的.md</a></li><li><a href="/book-docs/tcp-deep-analysis/9-TCP 恋爱史第一步 —— 从三次握手说起.html" class="sidebar-link">9-TCP 恋爱史第一步 —— 从三次握手说起.md</a></li><li><a href="/book-docs/tcp-deep-analysis/10-聊聊 TCP 自连接那些事.html" class="sidebar-link">10-聊聊 TCP 自连接那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/11-相见时难别亦难 —— 谈谈四次挥手.html" class="sidebar-link">11-相见时难别亦难 —— 谈谈四次挥手.md</a></li><li><a href="/book-docs/tcp-deep-analysis/12-时光机 —— TCP 头部时间戳选项.html" class="sidebar-link">12-时光机 —— TCP 头部时间戳选项.md</a></li><li><a href="/book-docs/tcp-deep-analysis/13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.html" class="sidebar-link">13-状态机魔鬼 —— TCP 11 种状态变迁及模拟重现.md</a></li><li><a href="/book-docs/tcp-deep-analysis/14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.html" class="sidebar-link">14-另辟蹊径看三次握手 —— 全连接队列和半连接队列与 backlog.md</a></li><li><a href="/book-docs/tcp-deep-analysis/15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.html" class="sidebar-link">15-原始但德高望重的 DDoS 攻击方式 —— SYN Flood 攻击原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/16-嫌三次握手太慢 —— 来快速打开吧.html" class="sidebar-link">16-嫌三次握手太慢 —— 来快速打开吧.md</a></li><li><a href="/book-docs/tcp-deep-analysis/17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.html" class="sidebar-link">17-Address already in use —— 聊聊 Socket 选项之 SO_REUSEADDR.md</a></li><li><a href="/book-docs/tcp-deep-analysis/18-一台主机上两个进程可以同时监听同一个端口吗.html" class="sidebar-link">18-一台主机上两个进程可以同时监听同一个端口吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/19-优雅关闭连接 —— Socket 选项之 SO_LINGER.html" class="sidebar-link">19-优雅关闭连接 —— Socket 选项之 SO_LINGER.md</a></li><li><a href="/book-docs/tcp-deep-analysis/20-一个神奇的状态 —— TIME_WAIT.html" class="sidebar-link">20-一个神奇的状态 —— TIME_WAIT.md</a></li><li><a href="/book-docs/tcp-deep-analysis/21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.html" class="sidebar-link">21-爱搞事情的 RST 包 —— 产生场景、Connection reset 与 Broken pipe.md</a></li><li><a href="/book-docs/tcp-deep-analysis/22-重传机制 —— 超时重传、快速重传与 SACK.html" class="sidebar-link">22-重传机制 —— 超时重传、快速重传与 SACK.md</a></li><li><a href="/book-docs/tcp-deep-analysis/23-重传间隔有讲究 —— 多久重传才合适.html" class="sidebar-link">23-重传间隔有讲究 —— 多久重传才合适.md</a></li><li><a href="/book-docs/tcp-deep-analysis/24-TCP流量控制 —— 滑动窗口.html" class="sidebar-link">24-TCP流量控制 —— 滑动窗口.md</a></li><li><a href="/book-docs/tcp-deep-analysis/25-有风度的 TCP —— 拥塞控制.html" class="sidebar-link">25-有风度的 TCP —— 拥塞控制.md</a></li><li><a href="/book-docs/tcp-deep-analysis/26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.html" class="sidebar-link">26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.md</a></li><li><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html" class="active sidebar-link">27-TCP 回包的磨叽姐 —— 延迟确认那些事.md</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html#什么时候需要回复-ack" class="sidebar-link">什么时候需要回复 ACK</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html#延迟确认实际例子演示" class="sidebar-link">延迟确认实际例子演示</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html#用-packetdrill-模拟延迟确认" class="sidebar-link">用 packetdrill 模拟延迟确认</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html#可以设置关掉延迟确认吗" class="sidebar-link">可以设置关掉延迟确认吗？</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html#当-nagle-算法遇到延迟确认" class="sidebar-link">当 Nagle 算法遇到延迟确认</a></li><li class="sidebar-sub-header"><a href="/book-docs/tcp-deep-analysis/27-TCP 回包的磨叽姐 —— 延迟确认那些事.html#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/book-docs/tcp-deep-analysis/28-兄弟你还活着吗 —— keepalive 原理.html" class="sidebar-link">28-兄弟你还活着吗 —— keepalive 原理.md</a></li><li><a href="/book-docs/tcp-deep-analysis/29-TCP RST 攻击与如何杀掉一条 TCP 连接.html" class="sidebar-link">29-TCP RST 攻击与如何杀掉一条 TCP 连接.md</a></li><li><a href="/book-docs/tcp-deep-analysis/30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.html" class="sidebar-link">30-ESTABLISHED 状态的连接收到 SYN 会回复什么？.md</a></li><li><a href="/book-docs/tcp-deep-analysis/31-定时器一览 —— 细数 TCP 的定时器们.html" class="sidebar-link">31-定时器一览 —— 细数 TCP 的定时器们.md</a></li><li><a href="/book-docs/tcp-deep-analysis/32-网络工具篇（一） —— telnet、nc、netstat.html" class="sidebar-link">32-网络工具篇（一） —— telnet、nc、netstat.md</a></li><li><a href="/book-docs/tcp-deep-analysis/33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.html" class="sidebar-link">33-网络工具篇（二） —— 网络包的照妖镜 tcpdump.md</a></li><li><a href="/book-docs/tcp-deep-analysis/34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.html" class="sidebar-link">34-网络命令篇（三） —— 网络分析屠龙刀 wireshark.md</a></li><li><a href="/book-docs/tcp-deep-analysis/35-案例分析 —— JDBC 批量插入真的就批量了吗.html" class="sidebar-link">35-案例分析 —— JDBC 批量插入真的就批量了吗.md</a></li><li><a href="/book-docs/tcp-deep-analysis/36-案例分析 —— TCP RST 包导致的网络血案.html" class="sidebar-link">36-案例分析 —— TCP RST 包导致的网络血案.md</a></li><li><a href="/book-docs/tcp-deep-analysis/37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.html" class="sidebar-link">37-案例分析 —— 一次 Zookeeper Connection Reset 问题排查.md</a></li><li><a href="/book-docs/tcp-deep-analysis/38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.html" class="sidebar-link">38-案例分析 —— 一次百万长连接压测 Nginx OOM 的问题排查分析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/39-作业题和思考题解析.html" class="sidebar-link">39-作业题和思考题解析.md</a></li><li><a href="/book-docs/tcp-deep-analysis/40-网络学习一路困难，与君共勉.html" class="sidebar-link">40-网络学习一路困难，与君共勉.md</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>这篇文章我们来介绍延迟确认。</p> <p>首先必须明确两个观点：</p> <ul><li>不是每个数据包都对应一个 ACK 包，因为可以合并确认。</li> <li>也不是接收端收到数据以后必须立刻马上回复确认包。</li></ul> <p>如果收到一个数据包以后暂时没有数据要分给对端，它可以等一段时间（Linux 上是 40ms）再确认。如果这段时间刚好有数据要传给对端，ACK 就可以随着数据一起发出去了。如果超过时间还没有数据要发送，也发送 ACK，以免对端以为丢包了。这种方式成为「延迟确认」。</p> <p>这个原因跟 Nagle 算法其实一样，回复一个空的 ACK 太浪费了。</p> <ul><li>如果接收端这个时候恰好有数据要回复客户端，那么 ACK 搭上顺风车一块发送。</li> <li>如果期间又有客户端的数据传过来，那可以把多次 ACK 合并成一个立刻发送出去</li> <li>如果一段时间没有顺风车，那么没办法，不能让接收端等太久，一个空包也得发。</li></ul> <p>这种机制被称为延迟确认（delayed ack），思破哥的文章把延迟确认（delayed-ack）称为「<strong>磨叽姐</strong>」，挺形象的。TCP 要求 ACK 延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。</p> <p>延迟确认在很多 linux 机器上是没有办法关闭的，</p> <p>那么这里涉及的就是一个非常根本的问题：「收到数据包以后什么时候该回复 ACK」</p> <h2 id="什么时候需要回复-ack"><a href="#什么时候需要回复-ack" class="header-anchor">#</a> 什么时候需要回复 ACK</h2> <p><a href="https://elixir.bootlin.com/linux/v2.6.11/source/net/ipv4/tcp_input.c" target="_blank" rel="noopener noreferrer">tcp_input.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language- extra-class"><pre><code>static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)
{
	struct tcp_sock *tp = tcp_sk(sk);

	    /* More than one full frame received... */
	if (((tp-&gt;rcv_nxt - tp-&gt;rcv_wup) &gt; tp-&gt;ack.rcv_mss
	     /* ... and right edge of window advances far enough.
	      * (tcp_recvmsg() will send ACK otherwise). Or...
	      */
	     &amp;&amp; __tcp_select_window(sk) &gt;= tp-&gt;rcv_wnd) ||
	    /* We ACK each frame or... */
	    tcp_in_quickack_mode(tp) ||
	    /* We have out of order data. */
	    (ofo_possible &amp;&amp;
	     skb_peek(&amp;tp-&gt;out_of_order_queue))) {
		/* Then ack it now */
		tcp_send_ack(sk);
	} else {
		/* Else, send delayed ack. */
		tcp_send_delayed_ack(sk);
	}
}
</code></pre></div><p>可以看到需要立马回复 ACK 的场景有：</p> <ul><li>如果接收到了大于一个frame 的报文，且需要调整窗口大小</li> <li>处于 quickack 模式（tcp_in_quickack_mode）</li> <li>收到乱序包（We have out of order data.）</li></ul> <p>其它情况一律使用延迟确认的方式</p> <p>需要重点关注的是：tcp_in_quickack_mode()</p> <div class="language- extra-class"><pre><code>/* Send ACKs quickly, if &quot;quick&quot; count is not exhausted
 * and the session is not interactive.
 */

static __inline__ int tcp_in_quickack_mode(struct tcp_sock *tp)
{
	return (tp-&gt;ack.quick &amp;&amp; !tp-&gt;ack.pingpong);
}

/* Delayed ACK control data */
struct {
	__u8	pending;	/* ACK is pending */
	__u8	quick;		/* Scheduled number of quick acks	*/
	__u8	pingpong;	/* The session is interactive		*/
	__u8	blocked;	/* Delayed ACK was blocked by socket lock*/
	__u32	ato;		/* Predicted tick of soft clock		*/
	unsigned long timeout;	/* Currently scheduled timeout		*/
	__u32	lrcvtime;	/* timestamp of last received data packet*/
	__u16	last_seg_size;	/* Size of last incoming segment	*/
	__u16	rcv_mss;	/* MSS used for delayed ACK decisions	*/ 
} ack;
</code></pre></div><p>内核 tcp_sock 结构体中有一个 ack 子结构体，内部有一个 quick 和 pingpong 两个字段，其中pingpong 就是判断交互连接的，只有处于非交互 TCP 连接才有可能即进入 quickack 模式。</p> <p>什么是交互式和 pingpong 呢？</p> <p>顾名思义，其实有来有回的双向数据传输就叫 pingpong，对于通信的某一端来说，<code>R-W-R-W-R-W...</code>（R 表示读，W 表示写）</p> <p>延迟确认出现的最多的场景是 <code>W-W-R</code>（写写读），我们来分析一下这种场景。</p> <h2 id="延迟确认实际例子演示"><a href="#延迟确认实际例子演示" class="header-anchor">#</a> 延迟确认实际例子演示</h2> <p>可以用一段 java 代码演示延迟确认。</p> <p>服务端代码如下，当从服务端 readLine 有返回非空字符串（读到<code>\n 或 \r</code>）就把字符串原样返回给客户端</p> <div class="language- extra-class"><pre><code>public class DelayAckServer {
    private static final int PORT = 8888;

    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket();
        serverSocket.bind(new InetSocketAddress(PORT));
        System.out.println(&quot;Server startup at &quot; + PORT);
        while (true) {
            Socket socket = serverSocket.accept();
            InputStream inputStream = socket.getInputStream();
            OutputStream outputStream = socket.getOutputStream();
            int i = 1;
            while (true) {
                BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
                String line = reader.readLine();
                if (line == null) break;
                System.out.println((i++) + &quot; : &quot; + line);
                outputStream.write((line + &quot;\n&quot;).getBytes());
            }
        }
    }
}
</code></pre></div><p>下面是客户端代码，客户端分两次调用 write 方法，模拟 http 请求的 header 和 body。第二次 write 包含了换行符（\n)，然后测量 write、write、read 所花费的时间。</p> <div class="language- extra-class"><pre><code>public class DelayAckClient {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket();
        socket.connect(new InetSocketAddress(&quot;server_ip&quot;, 8888));
        InputStream inputStream = socket.getInputStream();
        OutputStream outputStream = socket.getOutputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
        String head = &quot;hello, &quot;;
        String body = &quot;world\n&quot;;

        for (int i = 0; i &lt; 10; i++) {
            long start = System.currentTimeMillis();
            outputStream.write((&quot;#&quot; + i + &quot; &quot; + head).getBytes()); 
            outputStream.write((body).getBytes()); 
            String line = reader.readLine(); 
            System.out.println(&quot;RTT: &quot; + (System.currentTimeMillis() - start) + &quot;: &quot; + line);
        }
        inputStream.close();
        outputStream.close();
        socket.close();
    }
}
</code></pre></div><p>运行结果如下</p> <div class="language- extra-class"><pre><code>javac DelayAckClient.java; java -cp . DelayAckClient
RTT: 1: 
RTT: 44: 
RTT: 46: 
RTT: 44: 
RTT: 42: 
RTT: 41: 
RTT: 41: 
RTT: 44: 
RTT: 44: 
RTT: 44: 
</code></pre></div><p>除了第一次，剩下的 RTT 全为 40 多毫秒。这刚好是 Linux 延迟确认定时器的时间 40ms 抓包结果如下:</p> <p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a006acf0a4e73f" alt=""></p> <p>对包逐个分析一下 1 ~ 3：三次握手 4 ~ 9：第一次 for 循环的请求，也就是 W-W-R 的过程</p> <ul><li>4：客户端发送 &quot;#0 hello, &quot; 给服务端</li> <li>5：因为服务端只收到了数据还没有回复过数据，tcp 判断不是 pingpong 的交互式数据，属于 quickack 模式，立刻回复 ACK</li> <li>6：客户端发送 &quot;world\n&quot; 给服务端</li> <li>7：服务端因为还没有回复过数据，tcp 判断不是 pingpong 的交互式数据，服务端立刻回复 ACK</li> <li>8：服务端读到换行符，readline 函数返回，会把读到的字符串原样写入到客户端。TCP 这个时候检测到是 pingpong 的交互式连接，进入延迟确认模式</li> <li>9：客户端收到数据以后回复 ACK</li></ul> <p>10 ~ 14：第二次 for 循环</p> <ul><li>10：客户端发送 &quot;#1 hello, &quot; 给服务端。服务端收到数据包以后，因为处于 pingpong 模式，开启一个 40ms 的定时器，奢望在 40ms 内有数据回传</li> <li>11：很不幸，服务端等了 40ms 定期器到期都没有数据回传，回复确认 ACK 同时取消 pingpong 状态</li> <li>12：客户端发送 &quot;world\n&quot; 给服务端</li> <li>13：因为服务端不处于 pingpong 状态，所以收到数据立即回复 ACK</li> <li>14：服务端读到换行符，readline 函数返回，会把读到的字符串原样写入到客户端。这个时候又检测到收发数据了，进入 pingpong 状态。</li></ul> <p>从第二次 for 开始，后面的数据包都一样了。 整个过程包交互图如下：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a006ace9ddc4ef" alt=""></p> <h2 id="用-packetdrill-模拟延迟确认"><a href="#用-packetdrill-模拟延迟确认" class="header-anchor">#</a> 用 packetdrill 模拟延迟确认</h2> <div class="language- extra-class"><pre><code>--tolerance_usecs=100000
0.000 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3
0.000 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
0.000 bind(3, ..., ...) = 0
0.000 listen(3, 1) = 0

0.000 &lt; S 0:0(0) win 32792 &lt;mss 1000, sackOK, nop, nop, nop, wscale 7&gt;
0.000 &gt; S. 0:0(0) ack 1 &lt;...&gt;

0.000 &lt; . 1:1(0) ack 1 win 257

0.000 accept(3, ..., ...) = 4

+ 0 setsockopt(4, SOL_TCP, TCP_NODELAY, [1], 4) = 0

// 模拟往服务端写入 HTTP 头部: POST / HTTP/1.1
+0 &lt; P. 1:11(10) ack 1 win 257

// 模拟往服务端写入 HTTP 请求 body: {&quot;id&quot;: 1314}
+0 &lt; P. 11:26(15) ack 1 win 257

// 往 fd 为4 的 模拟服务器返回 HTTP response {}
+ 0 write(4, ..., 100) = 100
</code></pre></div><p>​<br>
// 第二次模拟往服务端写入 HTTP 头部: POST / HTTP/1.1
+0 &lt; P. 26:36(10) ack 101 win 257</p> <div class="language- extra-class"><pre><code>// 抓包看服务器返回

+0 `sleep 1000000`
</code></pre></div><p>这个构造包的过程跟前面的思路是一模一样的，抓包同样复现了 40ms 延迟的现象。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a006acecf83ba7" alt=""></p> <h2 id="可以设置关掉延迟确认吗"><a href="#可以设置关掉延迟确认吗" class="header-anchor">#</a> 可以设置关掉延迟确认吗？</h2> <p>这个是我刚开始学习 TCP 的一个疑惑，既然是 TCP 的一个特性，那有没有一个开关可以开启或者关闭延迟确认呢？ 答案是否定的，大部分 Linux 实现上并没有开关可以关闭延迟确认。我曾经以为它是一个 sysctl 项，可是后来找了很久都没有找到，没有办法通过一个配置彻底关掉或者开启 Linux 的延迟确认。</p> <h2 id="当-nagle-算法遇到延迟确认"><a href="#当-nagle-算法遇到延迟确认" class="header-anchor">#</a> 当 Nagle 算法遇到延迟确认</h2> <p>Nagle 算法和延迟确认本身并没有什么问题，但一起使用就会出现很严重的性能问题了。Nagle 攒着包一次发一个，延迟确认收到包不马上回。</p> <p>如果我们把上面的 Java 代码稍作调整，禁用 Nagle 算法可以试一下。</p> <div class="language- extra-class"><pre><code>Socket socket = new Socket();
socket.setTcpNoDelay(true); // 禁用 Nagle 算法
socket.connect(new InetSocketAddress(&quot;server ip&quot;, 8888));
</code></pre></div><p>运行 Client 端，可以看到 RTT 几乎为 0</p> <div class="language- extra-class"><pre><code>RTT: 1: 
RTT: 0: 
RTT: 1: 
RTT: 1: 
RTT: 0: 
RTT: 1: 
RTT: 1: 
RTT: 0: 
RTT: 1: 
RTT: 0: 
</code></pre></div><p>抓包结果如下</p> <p><img src="https://user-gold-cdn.xitu.io/2019/4/9/16a006aceed2734f" alt=""></p> <p>黑色背景部分的是客户端发送给服务端的请求包，可以看到在禁用 Nagle 的情况下，不用等一个包发完再发下一个，而是几乎同时把两次写请求发送出来了。服务端收到带换行符的包以后，立马可以返回结果，ACK 可以捎带过去，就不会出现延迟 40ms 的情况。</p> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>这篇文章主要介绍了延迟确认出现的背景和原因，然后用一个实际的代码演示了延迟确认的具体的细节。到这里 Nagle 算法和延迟确认这两个主题就介绍完毕了。</p> <p><a href="https://juejin.im/book/6844733788681928712/section/6844733788845506573" target="_blank" rel="noopener noreferrer">Source<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/book-docs/tcp-deep-analysis/26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.html" class="prev">
        26-TCP 发包的 hold 住哥 —— Nagle 算法那些事.md
      </a></span> <span class="next"><a href="/book-docs/tcp-deep-analysis/28-兄弟你还活着吗 —— keepalive 原理.html">
        28-兄弟你还活着吗 —— keepalive 原理.md
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/book-docs/tcp-deep-analysis/assets/js/app.411d3f03.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/2.8125d067.js" defer></script><script src="/book-docs/tcp-deep-analysis/assets/js/26.79028ade.js" defer></script>
  </body>
</html>
