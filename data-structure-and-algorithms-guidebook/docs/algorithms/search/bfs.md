---
nav:
  title: 算法
  order: 2
group:
  title: 搜索
  order: 3
title: 树图 - 广度优先搜索
order: 10
---

# 广度优先搜索

**广度优先搜索算法**（Breadth-First Search，缩写为 BFS），又译作**宽度优先搜索**，或**横向优先搜索**，是一种图形搜索算法。简单的说，BFS 是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用 open-closed 表。

## 处理顺序

在第一轮中，我们处理根结点。在第二轮中，我们处理根结点旁边的结点；在第三轮中，我们处理距根结点两步的结点；等等等等。

与树的层序遍历类似，`越是接近根结点的结点将越早地遍历`。

如果在第 `k` 轮中将结点 `X` 添加到队列中，则根结点与 `X` 之间的最短路径的长度恰好是 `k`。也就是说，第一次找到目标结点时，你已经处于最短路径中。

## 队列的入队和出队顺序是什么

如上面的动画所示，我们首先将根结点排入队列。然后在每一轮中，我们逐个处理已经在队列中的结点，并将所有邻居添加到队列中。值得注意的是，新添加的节点不会立即遍历，而是在下一轮中处理。

结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。

## 模版

之前，我们已经介绍了使用 BFS 的两个主要方案：`遍历` 或 `找出最短路径`。通常，这发生在树或图中。正如我们在章节描述中提到的，BFS 也可以用于更抽象的场景中。

在本文中，我们将为你提供一个模板。然后，我们在本文后提供一些习题供你练习。

> 在特定问题中执行 BFS 之前确定结点和边缘非常重要。通常，结点将是实际结点或是状态，而边缘将是实际边缘或可能的转换。

## 代码实现

广度优先遍历二叉树，也就是按层次去遍历。依次遍历根节点，然后是左子节点和右子节点。所以要遍历完当前节点的所有子节点。根据左右子节点的顺序来输出，所以就是先进先出的原则，那么我们当然就想到了队列这个数据结构。

### 递归版本

实现思路：

1. 创建 `nodeList` 存储最终返回结果
2. 创建一个队列存放
3. 当队列不为空时，获取队列第一元素，存进 `nodeList`
4. 遍历所有的子节点，存进队列尾部
5. 队列为空时推出循环并结束

```js
function bfs(node) {
  let nodeList = [];
  let index = 0;

  if (node != null) {
    nodeList.push(node);

    nodeList.push();
  }

  return nodeList;
}
```

### 非递归版本
